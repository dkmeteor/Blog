<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>DK&#39;s Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="DK's Lab">
<meta property="og:url" content="http://blog.dk-exp.com/page/2/index.html">
<meta property="og:site_name" content="DK's Lab">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DK's Lab">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="DK&#39;s Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?47d977b9cd46d5988a3e06ada67a7fa9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://dk-exp.qiniudn.com/logo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">DK</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/dkmeteor" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2699012760" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/ding-ke-53-78" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/circle/" style="font-size: 10px;">circle</a> <a href="/tags/list/" style="font-size: 10px;">list</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">DK</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://dk-exp.qiniudn.com/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">DK</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/dkmeteor" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2699012760" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/ding-ke-53-78" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-SurfaceView-flashes-black-on-load" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/17/SurfaceView-flashes-black-on-load/" class="article-date">
  	<time datetime="2015-10-16T21:37:52.000Z" itemprop="datePublished">2015-10-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/17/SurfaceView-flashes-black-on-load/">SurfaceView flashes black on load</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算更新一下<a href="https://github.com/dkmeteor/Bubble-Notification" target="_blank" rel="external">Bubble-Notification</a>.</p>
<p>之前所有效果都是通过在WindowMananger上添加DropCover,然后绘制在屏幕最顶层,类似悬浮窗的处理方案,为此应用需要拥有SYSTEM_ALERT权限(这里其实我的误解,使用TYPE_APPLICATION就不需要了).</p>
<p>后来想到参考SwipeBack/ResideMenu之类类库的,可以在DecorView上操作这些东西,这样就不需要权限了.</p>
<p>修改本身蛮简单的,不过修改完后发现,在效果最开始,屏幕会闪烁一下.</p>
<p>断点调了一会,是在SurfaceView被添加进DropCover后发生的,此时SurfaceView上还未进行任何绘制.</p>
<p>奇怪的是第二次再添加SurfaceView时,又不会闪烁了,因为修改以前运行是正常的,排除了绘制的问题以后.</p>
<p>搜索了一下,发现了这个</p>
<p><a href="http://www.mzule.com/%E9%81%BF%E5%85%8D-surfaceview-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%98%BE%E7%A4%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E9%BB%91%E5%B1%8F/" target="_blank" rel="external">http://www.mzule.com/%E9%81%BF%E5%85%8D-surfaceview-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%98%BE%E7%A4%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E9%BB%91%E5%B1%8F/</a></p>
<p><a href="http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load" target="_blank" rel="external">http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load</a></p>
<p>防止链接失效摘录一下原文:</p>
<pre><code>当 SurfaceView 第一次在 Window 里面显示的时候，会触发 IWindowSession.relayout(…) 方法，该方法会 relayout 整个布局，导致屏幕黑屏一下。解决方案，就是在 Activity 加入一个默认就显示的 SurfaceView，可以通过设置它的宽度为 0，来避免用户看见它。这样在 Fragment 里面的 SurfaceView 就已经是第二个 SurfaceView 了。可以重用上一个 SurfaceView 的参数，避免的明显的屏幕黑屏。
</code></pre><p>StackOverFlow上那个答案是这样:</p>
<pre><code>I think I found the reason for the black flash. In my case I&apos;m using a SurfaceView inside a Fragment and dynamically adding this fragment to the activity after some action. The moment when I add the fragment to the activity, the screen flashes black. I checked out grepcode for the SurfaceView source and here&apos;s what I found: when the surface view appears in the window the very fist time, it requests the window&apos;s parameters changing by calling a private IWindowSession.relayout(..) method. This method &quot;gives&quot; you a new frame, window, and window surface. I think the screen blinks right at that moment.

The solution is pretty simple: if your window already has appropriate parameters it will not refresh all the window&apos;s stuff and the screen will not blink. The simplest solution is to add a 0px height plain SurfaceView to the first layout of your activity. This will recreate the window before the activity is shown on the screen, and when you set your second layout it will just continue using the window with the current parameters. I hope this helps.
</code></pre><p>在MainActivity上添加了一个0px*0px的SurfaceView以后,问题确实解决了.</p>
<hr>
<p>但是这个解决方案实在太难看了,产生问题的原因也很反常.</p>
<p>查看SurfaceView的源码,可以找到上面所说的调用位置</p>
<pre><code>protected void updateWindow(boolean force, boolean redrawNeeded){
    ...
     relayoutResult = mSession.relayout(
                        mWindow, mWindow.mSeq, mLayout, mWidth, mHeight,
                            visible ? VISIBLE : GONE,
                            WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,
                            mWinFrame, mOverscanInsets, mContentInsets,
                            mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
    ...
} 
</code></pre><p>尝试了若干办法,绕过或者提前通过getWindow()获取Window对象设置参数都不行.</p>
<p>由于我是提供的类库,如果需要使用者自己去加个SurfaceView那也太操蛋了,这样Hack了一下</p>
<pre><code>public void init(Activity activity) {
if (mDropCover == null) {
    mDropCover = new DropCover(activity);
    mContainer = new FrameLayout(activity);

    ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
    decor.addView(mContainer);

    /**
     *
     *  WTF!
     *
     *  http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load
     *
     */
    SurfaceView s = new SurfaceView(activity);
    mContainer.addView(s);
    mContainer.post(new Runnable() {
        @Override
        public void run() {
            mContainer.removeAllViews();
        }
    });
}
</code></pre><p>StackOverFlow上那个提问记录还是2012年的…</p>
<hr>
<p>又仔细思索了一下,这种处理方式还是很操蛋,把这一部分重新改回了使用WindowMananger添加的方式</p>
<p>这里是我的理解有误</p>
<p>使用TYPE_APPLICATION就可以了,不需要权限.</p>
<p>之前使用的是TYPE_SYSTEM_ALERT,所以才需要权限,修改绕了一圈又回来了.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Android-6-0-flash-all-error-and-several-problems" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/15/Android-6-0-flash-all-error-and-several-problems/" class="article-date">
  	<time datetime="2015-10-15T05:55:31.000Z" itemprop="datePublished">2015-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/15/Android-6-0-flash-all-error-and-several-problems/">Android 6.0 刷机各种坑记录(防砖)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从preview3刷成了正式版6.0</p>
<p>几个坑有点蛋疼,记录下,免得下次刷成砖.</p>
<ul>
<li><p>下载下来的hammerhead-mra58k-factory-52364034.tar文件,解压缩后会获得一个无后缀的文件,修改后缀为zip后,再解压一次,才能看到flash脚本</p>
</li>
<li><p>直接执行flash-all. 刷preview3的时候,是直接flash-all就好了,这次刷正式版的时候,执行flash脚本以后一直提示system.img not found,检查了一下压缩包,system.img在里面,压缩包也没损坏,反复试了几次都是这个错误<br>不能直接一次全刷上,好在可以把image-hammerhead-mra58k.zip压缩包解压了,然后手动一个一个刷img</p>
</li>
</ul>
<pre><code>fastboot flash bootloader bootloader-hammerhead-hhz12k.img
fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.27.img

fastboot reboot-bootloader

fastboot flash recovery recovery.img
fastboot flash boot boot.img
fastboot flash system system.img
</code></pre><ul>
<li>刷完以后重启系统,正常开机,开始 应用优化 ,速度很慢.不过刷机以后能保留数据和应用不用去重装也是不错.然而这是个错误.进入系统以后发现几乎所有应用闪退.用root explorer的时候发现emulated文件夹下什么都看不见,才意识到可能是新的权限系统的问题.在设置-应用里翻了一下,果然所有非系统应用权限都是无.尝试修改应用权限失败,修改后重启没有变化.然后因为各种全家桶应用在不停的重启-崩溃-重启,整个手机非常卡.</li>
<li>老老实实重启fastboot 然后</li>
</ul>
<pre><code>fastboot flash cache cache.img
fastboot flash userdata userdata.img
</code></pre><ul>
<li>重启系统后,正常开机,依然很慢,然后就是开机引导和蛋疼的联网验证.这里有个很蛋疼的问题,这一步其实是要绑定google账户,因为那啥啥的原因,你肯定是联不上的,但是你手机插着sim卡,就会自动开启3G,当然你还是联不上,然后这一步也无法跳过.虽然有个跳过按钮,但是放了半个小时还是灰的.</li>
<li>正确的方法是,连接wifi(必须),高级里面proxy放一个https代理.这里应该是必须要https,反正我用http代理没成功过,不过免费代理本来就不稳定,也不确定.</li>
<li><p>然后等上一会,就发现可以跳过了,或者直接绑上也可以,我刷preview的时候是直接绑好了,这次可以跳过我就跳过了.</p>
</li>
<li><p>另外个方案是 不联网,把sim卡拔出来,应该也是能跳过这个验证步骤的,不过我取卡针不知道扔哪去了,卡拿不出来..</p>
</li>
<li><p>目前看起来还没发现什么问题,和preview3看起来也没什么区别.</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-about-vysor" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/03/about-vysor/" class="article-date">
  	<time datetime="2015-09-02T19:07:13.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/03/about-vysor/">Vysor</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近大家都在说vysor,于是我也弄来体验了一下.</p>
<p>只能说达不到预期的效果吧.</p>
<p>几个问题:</p>
<ul>
<li>帧率低</li>
<li>动画的时候画面会变模糊</li>
<li>手机熄屏后,vysor也黑了</li>
</ul>
<p>对于开发来讲,意义不是特别大.</p>
<p>你可以用GenyMotion或者Android Studio自带模拟器,体验基本上是一样的.</p>
<p>而必须用到真机测试的东西,往往你没法在vysor上完成,比如拍照,摇一摇之类的,测试的时候还是要把手机拿起来折腾</p>
<p><img src="/images/vysor_screen_shot.jpg" alt="img"></p>
<p>一般情况下还好,左右滑动的时候,就会迅速变得非常模糊,一会之后才会恢复.</p>
<p>不过如果电脑内存比较小,开了模拟器会爆内存的话,这个还是挺有用的,可以让你Build以后手不离开键盘鼠标就完成测试操作.减少打断和干扰吧.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Update-Radial-Blur-Library" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/03/Update-Radial-Blur-Library/" class="article-date">
  	<time datetime="2015-09-02T18:24:42.000Z" itemprop="datePublished">2015-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/03/Update-Radial-Blur-Library/">Update Radial Blur Library</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为看了@drakeet的FingerTransparentView想起来去年自己也写过一个类似的动态模糊(Motion Blur)的库</p>
<p>于是翻出来看了一下,花了点时间迁移到了Android Studio</p>
<p>在看的时候自己发现一个问题,这TM根本不是 <code>Motion Blur</code> ,我自己写的代码实际上实现的效果是 径向模糊(<code>Radial Blur</code>)</p>
<p>嘛…我还是要说一下 MotionBlur和RadialBlur看起来很像,但实际上是不一样的,我之前也是误解了,后来仔细看了些效果图,下面提到的几个库算法实现虽然名字都是叫MotionBlur,但是实现的效果其实都是RadialBlur</p>
<p>Demo效果</p>
<p><img src="https://raw.githubusercontent.com/dkmeteor/MotionBlur-Android/master/release/blur_center.png" alt="Examples list"></p>
<p>因为涉及到重复draw,当时我写得时候就记得性能很一般,这次迁移顺便也打算看看这个问题</p>
<p>核心代码其实很简单</p>
<pre><code>  public static Bitmap doRadialBlur(Bitmap src, int centerX, int centerY, float factor, int times) {

    Bitmap dst = Bitmap.createBitmap(src.getWidth(), src.getHeight(), Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(dst);
    Matrix matrix = new Matrix();
    Paint paint = new Paint();
    canvas.drawBitmap(src, matrix, paint);
    paint.setAlpha(51);

    for (int i = 0; i &lt; times; i++) {
        matrix.setScale(i * factor + 1, i * factor + 1, centerX, centerY);
        canvas.drawBitmap(src, matrix, paint);
    }
    return dst;
}
</code></pre><p>为了实现效果需要反复的Scale并重复的draw同一张Bitmap,性能当然狠捉急.<br>测试时发现渲染一次需要 1400ms 左右.</p>
<p>图片是2400<em>2400的,换成800</em>800的以后,减少到200ms左右,作为一个滤镜来讲,尚可接受吧,一时间也想不到什么优化的方法.<br>优化到16ms以下可以做成实时滤镜,否则的话,似乎意义不大.</p>
<p>想起jhlab也有 径向模糊 的滤镜算法,于是拔出来代码看了下</p>
<pre><code> public BufferedImage filter( BufferedImage src, BufferedImage dst ) {
    if ( dst == null )
        dst = createCompatibleDestImage( src, null );
    BufferedImage tsrc = src;
    float cx = (float)src.getWidth() * centreX;
    float cy = (float)src.getHeight() * centreY;
    float imageRadius = (float)Math.sqrt( cx*cx + cy*cy );
    float translateX = (float)(distance * Math.cos( angle ));
    float translateY = (float)(distance * -Math.sin( angle ));
    float scale = zoom;
    float rotate = rotation;
    float maxDistance = distance + Math.abs(rotation*imageRadius) + zoom*imageRadius;
    int steps = log2((int)maxDistance);

    translateX /= maxDistance;
    translateY /= maxDistance;
    scale /= maxDistance;
    rotate /= maxDistance;

    if ( steps == 0 ) {
        Graphics2D g = dst.createGraphics();
        g.drawRenderedImage( src, null );
        g.dispose();
        return dst;
    }

    BufferedImage tmp = createCompatibleDestImage( src, null );
    for ( int i = 0; i &lt; steps; i++ ) {
        Graphics2D g = tmp.createGraphics();
        g.drawImage( tsrc, null, null );
        g.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
        g.setRenderingHint( RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR );
        g.setComposite( AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 0.5f ) );

        g.translate( cx+translateX, cy+translateY );
        g.scale( 1.0001+scale, 1.0001+scale );  // The .0001 works round a bug on Windows where drawImage throws an ArrayIndexOutofBoundException
        if ( rotation != 0 )
            g.rotate( rotate );
        g.translate( -cx, -cy );

        g.drawImage( dst, null, null );
        g.dispose();
        BufferedImage ti = dst;
        dst = tmp;
        tmp = ti;
        tsrc = dst;

        translateX *= 2;
        translateY *= 2;
        scale *= 2;
        rotate *= 2;
    }
    return dst;
}
</code></pre><p>Jhlabs比较古老,BufferedImage是awt里面,做Android的如果不了解的话当Bitmap理解就好了.<br>可以看到Jhlabs的代码逻辑也没什么区别,一样是通过反复draw image实现的径向模糊效果.</p>
<p>参考意义不大.</p>
<p>另外在Github上搜索了一下,一个叫做AndroidFastImageProcessing的库也支持MotionBlur,其实现机制比较特别</p>
<p>核心代码是这样</p>
<pre><code>protected String getFragmentShader() {
    return 
             &quot;precision mediump float;\n&quot; 
            +&quot;uniform sampler2D &quot;+UNIFORM_TEXTURE0+&quot;;\n&quot;  
            +&quot;varying vec2 &quot;+VARYING_TEXCOORD+&quot;;\n&quot;    
            +&quot;uniform float &quot;+UNIFORM_TEXELWIDTH+&quot;;\n&quot;
            +&quot;uniform float &quot;+UNIFORM_TEXELHEIGHT+&quot;;\n&quot;

              +&quot;void main(){\n&quot;
              +&quot;   vec2 step = vec2(&quot;+UNIFORM_TEXELWIDTH+&quot;, &quot;+UNIFORM_TEXELHEIGHT+&quot;);\n&quot;
              +&quot;   vec4 fragColour = texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot;) * 0.18;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; + step) * 0.15;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; - step) * 0.15;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; + step * 2.0) * 0.12;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; - step * 2.0) * 0.12;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; + step * 3.0) * 0.09;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; - step * 3.0) * 0.09;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; + step * 4.0) * 0.05;\n&quot;
              +&quot;   fragColour += texture2D(&quot;+UNIFORM_TEXTURE0+&quot;, &quot;+VARYING_TEXCOORD+&quot; - step * 4.0) * 0.05;\n&quot;
              +&quot;   gl_FragColor = fragColour;\n&quot;
              +&quot;}\n&quot;;
}
</code></pre><p>可以看到 这是生成了一段代码</p>
<p>然后对应的执行部分</p>
<pre><code>GLES20.glShaderSource(fragmentShaderHandle, fragmentShader);
GLES20.glCompileShader(fragmentShaderHandle);
</code></pre><p>好吧,其实我压根就不懂OpenGl.大概是把图片作为Shader进行了多次渲染来实现MontionBlur的效果.</p>
<p>这个研究基本上没有结果,往下层去看都是native方法,OpenGl可能是一个可行的优化方法,可惜是我不懂OpenGL,看了一点点实在没什么头绪,可能需要系统的从头学习一下.</p>
<hr>
<p>然后过程中还发现个比较奇特的问题</p>
<p>将项目发布到jcenter以后,打算自己测试一下,但是一直编译不过,提示如下:</p>
<pre><code>Error:A problem occurred configuring project &apos;:app&apos;.
&gt; Could not resolve all dependencies for configuration &apos;:app:_debugCompile&apos;.
   &gt; Could not resolve com.dk.image.process.radialblur:library:0.1.0.
     Required by:
         MotionBlur-Android:app:unspecified
      &gt; Could not resolve com.dk.image.process.radialblur:library:0.1.0.
         &gt; Could not get resource &apos;https://jcenter.bintray.com/com/dk/image/process/radialblur/library/0.1.0/library-0.1.0.pom&apos;.
            &gt; Could not HEAD &apos;https://jcenter.bintray.com/com/dk/image/process/radialblur/library/0.1.0/library-0.1.0.pom&apos;. Received status code 400 from server: Bad Request
</code></pre><p>我自己反复确认了几次, <a href="https://jcenter.bintray.com/com/dk/image/process/radialblur/library/0.1.0/library-0.1.0.pom" target="_blank" rel="external">https://jcenter.bintray.com/com/dk/image/process/radialblur/library/0.1.0/library-0.1.0.pom</a> 绝对是可以访问的.</p>
<p>然后我一想,可能是代理的问题,但是我确定自己肯定没给Android Studio配过代理,因为我自己用的代理是 红杏,需要全局代理的时候我用的mxvpm需要客户端登陆,根本不会在Android Studio里配置,<br>不过还是检查了下Android Studio的代理配置,代理配置确实是空的,但是最顶部有一个Warnning提示,提示我JVM里配置了一个Proxy</p>
<p><code>mirrors.opencas.cn</code></p>
<p>我其实不大理解什么叫JVM PROXY,不过这个代理服务器地址我一看就知道是我在SDK Manager里使用的镜像的地址,我也不知道为什么Android Studio会把SDK Manager里的配置读过来,之前是从来没有过的.<br>打开SDK Manager,删掉镜像配置,重启Android Studio,恢复了正常,denpendices可以正常sync.</p>
<p>关掉Android Studio,再打开SDK Manager,把镜像重新配回去.重启Android Studio,检查代理设置,正常.</p>
<p>这我就不理解了,什么情况下Android Studio会读取SDK Mananger的代理配置,什么时候不会?</p>
<p>出现问题的版本 Android Studio版本1.3.1 </p>
<p>之前从来没有遇到过,因为我SDK Manager里一直是挂着镜像的地址.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-关于Looper的瞎扯蛋" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/26/关于Looper的瞎扯蛋/" class="article-date">
  	<time datetime="2015-08-25T22:42:48.000Z" itemprop="datePublished">2015-08-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/26/关于Looper的瞎扯蛋/">关于Looper的瞎扯蛋</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#关于Looper的瞎扯蛋</p>
<p>知乎有这么一个问题</p>
<p><a href="http://www.zhihu.com/question/34652589" target="_blank" rel="external">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a></p>
<hr>
<p>这问题本身其实很简单,对Android有一定了解的都会学习Handler Looper MessageQueue相关的知识,面试的时候我也喜欢问别人这个问题.</p>
<pre><code>for (;;) {
    Message msg = queue.next(); // might block
    if (msg == null) {
        // No message indicates that the message queue is quitting.
        return;
    }

    // This must be in a local variable, in case a UI event sets the logger
    Printer logging = me.mLogging;
    if (logging != null) {
        logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                msg.callback + &quot;: &quot; + msg.what);
    }

    msg.target.dispatchMessage(msg);

    if (logging != null) {
        logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
    }

    // Make sure that during the course of dispatching the
    // identity of the thread wasn&apos;t corrupted.
    final long newIdent = Binder.clearCallingIdentity();
    if (ident != newIdent) {
        Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                + Long.toHexString(ident) + &quot; to 0x&quot;
                + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                + msg.target.getClass().getName() + &quot; &quot;
                + msg.callback + &quot; what=&quot; + msg.what);
    }

    msg.recycleUnchecked();
}
</code></pre><p>要我简单点回答的话,我觉得答案就是 阻塞队列 <code>BlockingQueue</code></p>
<p>这里比较有意思的这个问题里的有个些答案让我很意外</p>
<pre><code>著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
作者：TracyB
链接：http://www.zhihu.com/question/34652589/answer/59722754
来源：知乎


epoll+pipe，有消息就依次执行，没消息就block住，让出CPU，等有消息了，epoll会往pipe中写一个字符，把主线程从block状态唤起，主线程就继续依次执行消息，怎么会死循环呢…
</code></pre><p>这个逻辑我猜大概是这样</p>
<p>为什么不会死循环 –&gt; 这里使用了阻塞队列 –&gt; 阻塞队列底层调度如何实现 –&gt; epoll</p>
<p>我猜这人大概是做Framework层 或 ROM开发的, 一般Android程序员恐怕不会从这个角度去想问题.</p>
<hr>
<p>ps.顺便一提</p>
<p>Looper中通过 <code>ThreadLocal</code> 来为每个线程分配隔离的 Looper对象</p>
<pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
</code></pre><p>关于ThreadLocal,以前都是当做Java特性的来理解这个东西的,无聊看了下源代码</p>
<p>实现机制其实非常简洁,我觉得我以前看过的书上 对 ThreadLocal的介绍&amp;分析真是浪费时间, 核心代码也没几行, 看源码5分钟就能理解的东西,书上啰啰嗦嗦的讲上N页</p>
<pre><code>public T get() {
    // Optimized for the fast path.
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values != null) {
        Object[] table = values.table;
        int index = hash &amp; values.mask;
        if (this.reference == table[index]) {
            return (T) table[index + 1];
        }
    } else {
        values = initializeValues(currentThread);
    }

    return (T) values.getAfterMiss(this);
}

public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}

Values values(Thread current) {
    return current.localValues;
}
</code></pre><p>几个关键方法源代码一看,每个Thread会持有一个localValues对象,set的时候,对象被直接塞给了localValues<br>localValues是一个类似HashMap的数据结构,ThreadLocal对象自身做key</p>
<p>简单明了,看代码根本不会产生任何理解上的误差,以前像记概念一样看这个东西真是犯傻.</p>
<hr>
<p>ps2.顺便我就想到了volatile</p>
<p>这个玩意也是一直是当做概念去记的. 比如JAVA核心技术上用了一大段晦涩的文字来描述这是个什么玩意,印象中还在其它书上看到更复杂的解释.</p>
<p>实际上 一旦更深入的划分 <code>内存</code> 这个概念 , 这个东西就很好理解了,而且不会再记错用错.</p>
<p>CPU寄存器中的cache是内存, JVM的 线程工作内存 也是内存.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Performance-update-for-Folder-ResideMenu" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/14/Performance-update-for-Folder-ResideMenu/" class="article-date">
  	<time datetime="2015-06-14T15:42:20.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/Performance-update-for-Folder-ResideMenu/">Folder-ResideMenu性能优化(Performance update for Folder-ResideMenu)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Folder-ResideMenu性能优化(Performance update for Folder-ResideMenu)</p>
<p>Folder-ResideMenu的核心部分算完成了,剩下的就是修复一些bug,于是我顺便做了下性能测试<br>结果如下:</p>
<p><img src="../images/folder-residemenu-performance-bad.png" alt="image"></p>
<p>WTF??!!</p>
<p>目测单帧 50ms左右.</p>
<p>好吧,于是我给自己开了个issue并且着手修复这个问题.</p>
<p><a href="https://github.com/dkmeteor/Folder-ResideMenu/issues/3" target="_blank" rel="external">https://github.com/dkmeteor/Folder-ResideMenu/issues/3</a></p>
<p>恩,这一定是个bug..</p>
<hr>
<ul>
<li>首先观察一下Logcat , 没有任何异常输出</li>
<li>看一下Memory monitor , 额…内存抖动….</li>
</ul>
<p><img src="../images/folder-residemenu-performance-memory-monitor.png" alt="image"></p>
<pre><code>public float[] createOffsetVerts(float offset, float pointerY) {
    applyCurveXEffect(offset);
    applyScaleXEffect(offset, pointerY);
    mShader = applyShadow(offset);
    return meshVerts;
}
</code></pre><p>算法核心在这里,一开始设计的时候就将效果分解成若干步了,正好可以分开一个一个调试.</p>
<p>因为公式太复杂了,写在一起 代码-&gt;公式 脑子里映射不出来,改起来太吃力,否则在一个循环里把verts都算好性能更好,不过那样就完全没有可读性了,至少我自己是看不懂了…</p>
<p>分别把每个步骤注释了再运行一下试试.<br>(虽然看到内存抖动的时候就想到大概是BitmapShader的问题了)</p>
<p>可以看到,干掉Shader以后,性能获得了无与伦比的提示</p>
<p><img src="../images/folder-residemenu-performance-no-shader.png" alt="image"></p>
<p>目测提升了10倍吧…单帧在4ms左右…<br>Shader就是扭曲效果之上渲染的阴影,发个对比图比较直观</p>
<p>阴影的Alpha会随着滑动不断加深来模拟褶皱越来越深的效果</p>
<p>无Shader <strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong> 有Shader</p>
<p><img src="../images/folder-residemenu-performance-without-shader.png" alt="image">   <img src="../images/folder-residemenu-performance-with-shader.png" alt="image"></p>
<p>找到关键点以后事情就变得简单了</p>
<p>生成Shader的代码</p>
<pre><code>private Shader applyShadow(float offset) {

    float p1 = (float) Math.sqrt(Math.PI / 2 * SIN_lENGTH_FACTOR);
    float p2 = (float) Math.sqrt((Math.PI / 2 + 1 * Math.PI) * SIN_lENGTH_FACTOR);
    float p3 = (float) Math.sqrt((Math.PI / 2 + 2 * Math.PI) * SIN_lENGTH_FACTOR);
    float p4 = (float) Math.sqrt((Math.PI / 2 + 3 * Math.PI) * SIN_lENGTH_FACTOR);
    float p5 = (float) Math.sqrt((Math.PI / 2 + 4 * Math.PI) * SIN_lENGTH_FACTOR);
    float p6 = (float) Math.sqrt((Math.PI / 2 + 5 * Math.PI) * SIN_lENGTH_FACTOR);
    float p7 = (float) Math.sqrt((Math.PI / 2 + 6 * Math.PI) * SIN_lENGTH_FACTOR);
    float p8 = (float) Math.sqrt((Math.PI / 2 + 7 * Math.PI) * SIN_lENGTH_FACTOR);
    float p9 = (float) Math.sqrt((Math.PI / 2 + 8 * Math.PI) * SIN_lENGTH_FACTOR);

    int gray = ((int) (mAlpha * ((1l - offset) * 1f)) &lt;&lt; 24)
            | GRAY;
    Shader shader = null;

    if (mDirection == TouchDisableView.DIRECTION_RIGHT) {
        shader = new LinearGradient(0, 0, width, 0, new int[]{gray,
                TRANSPARENT, gray, TRANSPARENT, gray, TRANSPARENT, gray,
                TRANSPARENT, gray}, new float[]{p1 / width, p2 / width,
                p3 / width, p4 / width, p5 / width, p6 / width, p7 / width,
                p8 / width, p9 / width}, Shader.TileMode.REPEAT);
    } else {
        shader = new LinearGradient(0, 0, width, 0, new int[]{gray,
                TRANSPARENT, gray, TRANSPARENT, gray, TRANSPARENT, gray,
                TRANSPARENT, gray}, new float[]{(1 - p9 / width), (1 - p8 / width),
                (1 - p7 / width), (1 - p6 / width), (1 - p5 / width), (1 - p4 / width), (1 - p3 / width),
                (1 - p2 / width), (1 - p1 / width)}, Shader.TileMode.REPEAT);
    }
    return shader;
}
</code></pre><p>看起来有些小问题,每次回调的时候会根据offset值重新计算 Shader的颜色(Alpha)<br>每次setFolder回调都会new出一个新的 <code>LinearGradient</code> 对象</p>
<p>上面一大堆常量可以扔出去,不用每次都计算</p>
<p>但是都不像是会引起内存抖动的问题. ‘LinearGradient’这个对象并不大,即使每帧都new一个,也不会产生肉眼可见的内存抖动…</p>
<p>不过也可以优化一下,显然,更新Shader只是为了调整阴影的透明度,这工作扔到paint上做就好了</p>
<p>修改为每次 <code>setDirection</code> 时,将mShader设置为null</p>
<p>然后</p>
<pre><code>if (mShader == null)
    mShader = applyShadow(offset);
</code></pre><p>将ShaderAlpha移到MeshImageView中.由Paint去处理Shadow层的alpha问题.</p>
<p>再顺着Shader找找Shader处理阴影层的地方</p>
<pre><code>@Override
public void draw(Canvas canvas) {
    super.draw(canvas);
    if (mPaint == null)
        mPaint = new Paint();

    if (mShader != null) {
        mShaderBitmap = Bitmap.createBitmap(canvas.getWidth(),
                canvas.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas tempCanvas = new Canvas(mShaderBitmap);
        Paint paint = new Paint();
        paint.setShader(mShader);
        paint.setAlpha((int)(mShaderAlpha * 255f));
        tempCanvas.drawPaint(paint);
    }
    if (mVerts != null) {
        canvas.drawBitmapMesh(mBitmap, 50, 5, mVerts, 0, null, 0, null);
        if (mShaderBitmap != null)
            canvas.drawBitmapMesh(mShaderBitmap, 50, 5, mVerts, 0, null, 0,
                    null);
    } else
        canvas.drawBitmap(mBitmap, new Matrix(), mPaint);
}
</code></pre><p>Shit , 竟然在draw里去生成Bitmap……看来内存抖动就是它了….<br>仔细回忆了一下…我也想不起来当初为什么这么写了…可能只是为了更新阴影状态??<br>(无论任何时候,你看你三个月前写的代码,都觉得是一坨狗屎)<br>修改后如下</p>
<pre><code>@Override
public void draw(Canvas canvas) {
    super.draw(canvas);
    if (mPaint == null)
        mPaint = new Paint();

    if (mShader != null &amp;&amp; mShaderBitmap == null) {
        mShaderBitmap = Bitmap.createBitmap(canvas.getWidth(),
                canvas.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas tempCanvas = new Canvas(mShaderBitmap);
        Paint paint = new Paint();
        paint.setShader(mShader);
        tempCanvas.drawPaint(paint);
    }
    if (mVerts != null) {
        canvas.drawBitmapMesh(mBitmap, 50, 5, mVerts, 0, null, 0, null);
        if (mShaderBitmap != null) {
            mAlphaPaint.setAlpha((int) (mShaderAlpha * 255f));
            canvas.drawBitmapMesh(mShaderBitmap, 50, 5, mVerts, 0, null, 0,
                    mAlphaPaint);
        }
    } else
        canvas.drawBitmap(mBitmap, new Matrix(), mPaint);
}
</code></pre><p>tempCanvas只会创建一次,看来仍在这里也没什么问题</p>
<p>再跑起来看一下</p>
<p> <img src="../images/folder-residemenu-performance-result.png" alt="image"></p>
<p>哦哦 看起来非常不错了…..</p>
<p>对比一下QQ</p>
<p> <img src="../images/folder-residemenu-performance-qq.png" alt="image"></p>
<p>当然QQ整个View比我这个Demo复杂的多,光View层级就得复杂个几十倍把,<br>不过这锯齿形的帧率也很奇怪..</p>
<p>但是我注意到….我的有2帧绘制的非常慢?<br>What is that?</p>
<p>反复操作了几次以后发现,那个长条就是缩放动画开始的第一帧…<br>第一帧之前做了什么? 截取当前View生成Bitmap<br>把当前ContentView偷偷换成了Bitmap截图<br>当然,根据优化后的代码,还生成了一个ShaderBitmap</p>
<p>ok</p>
<p>下一步来研究这个问题…</p>
<hr>
<p>首先可以想到,最容易造成性能问题的,自然就是 Bitmap生成了<br>还记得上面做的Shader优化的话<br>我们会在 动画触发 的时候</p>
<p>生成一个 BitmapShader</p>
<p>简单的添加了个log</p>
<p>05-28 16:23:03.908    4153-4153/com.dk.sample.folder.residemenu I/System.out﹕ CreateShader:34</p>
<p>反复运行了几次以后，发现生成Shader大约在25~35ms左右<br>这样的话 这一帧渲染时间当然一定会超过16ms了…</p>
<p>仔细思考一下这个系统,我其实只需要2个方向的不同Shader<br>也许预先把他们生成好并cache起来,就不必在ondraw时再去生成了<br>反正Shader和content内容本身没什么关系…</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-why-thead-can-not-modify-UI-elements" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/05/why-thead-can-not-modify-UI-elements/" class="article-date">
  	<time datetime="2015-05-05T08:43:11.000Z" itemprop="datePublished">2015-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/why-thead-can-not-modify-UI-elements/">从源码分析 对 非UI线程不允许访问UI元素的 理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在eoe回答了一个问题：<br><a href="http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=579938&amp;page=1" target="_blank" rel="external">http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=579938&amp;page=1</a></p>
<p>索性把内容整理一下…</p>
<hr>
<p>做Android开发初期大部分开发者都会遇到下面这个问题.</p>
<pre><code>android.view.viewroot$calledfromwrongthreadexception: only the original thread that created a view hierarchy can touch its views.
</code></pre><p>原因大半都是 由于在异步线程中视图 更新界面中的元素</p>
<p>百度一搜,可以搜到大量解决办法.</p>
<p>结果提炼一下: 大致就是讲 UI元素/视图元素 必须在 UI线程(主线程)中更新修改.</p>
<p>新手这样理解就够了.</p>
<hr>
<p>但是仔细看这个Exception说明</p>
<p><code>only the original thread that created a view hierarchy can touch its views.</code></p>
<p>里面并没有提到 主线程/UI 线程,只是提到,必须是创建<code>View hierarchy</code>的线程</p>
<p>!注意区分</p>
<p>创建View的线程和创建View hierarchy的不一定是同一个线程,不要理解错了,下面在源码中具体分析</p>
<p>观察ViewRoot源码中抛出calledfromwrongthreadexception的位置</p>
<pre><code>void checkThread() {

    if (mThread != Thread.currentThread()) {

        throw new CalledFromWrongThreadException(
                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);
    }
}
</code></pre><p>可以注意到 这里只检查了 当前执行线程和 mThread是否为同一个线程</p>
<pre><code>public ViewRoot(Context context) {

     super();
     if (MEASURE_LATENCY &amp;amp;&amp;amp; lt == null) {
         lt = new LatencyTimer(100, 1000);
     }

     // For debug only
     //++sInstanceCount;
     // Initialize the statics when this class is first instantiated. This is
     // done here instead of in the static block because Zygote does not
     // allow the spawning of threads.

     getWindowSession(context.getMainLooper());

     mThread = Thread.currentThread();
</code></pre><p>由ViewRoot的构造函数可以看到,mThread被绑定在了 创建<code>viewRoot</code>的线程上.</p>
<p>当然大部分情况下,<code>ViewRoot</code>都是在主线程中创建的,所以在异步线程中修改view会造成checkThread失败.</p>
<p>mTextView.setText(“123”);为例子.</p>
<p>跟踪一下调用栈</p>
<pre><code>-- android.widget.TextView.setText

  -- android.widget.TextView.checkForRelayout

    -- android.view.View.invalidate

        -- android.view.ViewGroup.invalidateChild

          -- android.view.ViewRoot.invalidateChildInParent

            -- android.view.ViewRoot.invalidateChild

              -- android.view.ViewRoot.checkThread
</code></pre><p>可以看到 view会不断遍历去获取 ViewParent<br>一个视图上的View遍历到最后 就是 获取到了 ViewRoot</p>
<p>(ViewRoot本身就是ViewParent的一个子类)</p>
<p>然后就会调用到上面提到的 checkThread()</p>
<p>到这里有一个结论:</p>
<p>UI修改操作确实会验证操作的线程</p>
<pre><code>* * *
</code></pre><p>回到标题上来说, 因为 ViewRoot是由UI线程创建的,所以所有被添加到ViewRoot下的子View都必须在UI线程中修改,看起来也很合理.<br>那么,有可能在非UI线程中创建ViewRoot吗?</p>
<p>其实是可以的.</p>
<p>这里就涉及到ViewRoot和WindowManager之间的关系</p>
<p>demo代码如下:</p>
<pre><code>package com.dk.asyncui;

import android.app.Activity;
import android.graphics.PixelFormat;
import android.os.Bundle;
import android.os.Looper;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;

public class MainActivity extends Activity {
    private Button mButton ;
    private WindowManager mWindowManager ;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
          setContentView(R.layout. activity_main);

           mWindowManager = (WindowManager) getSystemService(&quot;window&quot; );

           mButton = new Button(this );
           mButton.setText( &quot;HelloWorld&quot;);

          Thread mthread = new Thread(new Runnable() {

                  @Override
                  public void run() {
                       Looper. prepare();
                       WindowManager.LayoutParams wmParams = new WindowManager.LayoutParams();
                       wmParams. type = WindowManager.LayoutParams.TYPE_APPLICATION ;
                       wmParams. format = PixelFormat. RGBA_8888;
                       wmParams. flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL ;
                       wmParams. width = 320;
                       wmParams. height = 140;
                        mWindowManager.addView(mButton , wmParams);
                       Looper. loop();

                 }
          });
          mthread.start();
           mButton.setOnClickListener( new View.OnClickListener() {

                  @Override
                  public void onClick(View v) {

                       runOnUiThread( new Runnable() {
                               public void run() {
                                      mButton.setText( &quot;22222222&quot;);
                              }
                       });
                 }
          });
   }

}
</code></pre><p>可以看到,我在异步线程中将 mButton添加到 WindowManager中</p>
<p>查看 WindowManangerImpl中addView的代码：</p>
<pre><code>public void addView(View view, ViewGroup.LayoutParams params,
        Display display, Window parentWindow) {
    if (view == null) {
        throw new IllegalArgumentException(&quot;view must not be null&quot;);
    }

    if (display == null) {
        throw new IllegalArgumentException(&quot;display must not be null&quot;);
    }

    if (!(params instanceof WindowManager.LayoutParams)) {
        throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);
    }
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
    if (parentWindow != null) {
        parentWindow.adjustLayoutParamsForSubWindow(wparams);
    }
    ViewRootImpl root;
    View panelParentView = null;

    synchronized (mLock) {
        // Start watching for system property changes.

        if (mSystemPropertyUpdater == null) {
            mSystemPropertyUpdater = new Runnable() {
                @Override public void run() {
                    synchronized (mLock) {
                        for (int i = mRoots.size() - 1; i &amp;gt;= 0; --i) {
                            mRoots.get(i).loadSystemProperties();
                        }
                    }
                }
            };
            SystemProperties.addChangeCallback(mSystemPropertyUpdater);
        }
        int index = findViewLocked(view, false);
        if (index &amp;gt;= 0) {
            if (mDyingViews.contains(view)) {
                // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.
                mRoots.get(index).doDie();
            } else {
                throw new IllegalStateException(&quot;View &quot; + view
                        + &quot; has already been added to the window manager.&quot;);
            }
            // The previous removeView() had not completed executing. Now it has.
        }
        // If this is a panel window, then find the window it is being
        // attached to for future reference.
        if (wparams.type &amp;gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;amp;&amp;amp;
                wparams.type &amp;lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
            final int count = mViews.size();
            for (int i = 0; i &amp;lt; count; i++) {
                if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                    panelParentView = mViews.get(i);
                }
            }
        }
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
    }

    // do this last because it fires off messages to start doing things
    try {
        root.setView(view, wparams, panelParentView);
    } catch (RuntimeException e) {
        // BadTokenException or InvalidDisplayException, clean up.
        synchronized (mLock) {
            final int index = findViewLocked(view, false);
            if (index &amp;gt;= 0) {
                removeViewLocked(index, true);
            }
        }
        throw e;
    }
}
</code></pre><p>可以发现在addView的过程中 WindowMananger创建了 ViewRoot</p>
<p>这就是上面提到的在 异步线程中创建 ViewRoot</p>
<p>上面Demo代码中的 runOnUiThread是为了保证下面的<br>  mButton.setText( “22222222” );</p>
<p>是在主线程中执行<br>可以看到,这段代码即使是在主线程中执行,依然抛出了CalledFromWrongThreadException</p>
<p>在特意构造的这个特殊场景下,主线程/UI线程中 不能更新在异步线程中”创建/添加”的UI元素!!</p>
<hr>
<p>从源码和设计的角度上分析,我倾向于认为这其实是设计上的一个漏洞,我通过这个漏洞创建了一个非主线程绑定的ViewRoot对象,才会导致上面的结果.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a><a class="article-category-link" href="/categories/android/Blog/">Blog</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-patheffecttextview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/02/patheffecttextview/" class="article-date">
  	<time datetime="2015-04-02T07:41:09.000Z" itemprop="datePublished">2015-04-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/02/patheffecttextview/">PathEffectTextView</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/path_hello_world.gif" alt="path3"></p>
<p><img src="/images/path_mulitpy.gif" alt="path2"></p>
<p><img src="/images/path_single.gif" alt="path1"></p>
<p><a href="https://github.com/dkmeteor/PathEffectTextView" target="_blank" rel="external">https://github.com/dkmeteor/PathEffectTextView</a></p>
<p>90%完成吧…</p>
<p>昨天因为一个比较傻逼的原因看了半天为何Path画出来没效果….甚至以为PathMeasure的作用机制和我预想的不同，结果是因为Paint没在STROKE模式，简直醉了…..</p>
<p>与PathEffect结合使用可以做出更好的效果，不过目前并没有用到…..嘛…..反正标题就这样也懒得改了..以后无聊了再加吧..</p>
<p>与SVG解析器一起使用的话，理论上是任意图形都可以用这种方式做动效…</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a><a class="article-category-link" href="/categories/android/Blog/">Blog</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-checkbox-paddingleft" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/26/checkbox-paddingleft/" class="article-date">
  	<time datetime="2015-03-26T08:30:09.000Z" itemprop="datePublished">2015-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/26/checkbox-paddingleft/">关于CheckBox的PaddingLeft</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在不同Android版本中对PaddingLeft的计算方式不同</p>
<p>在Android 4.1.2 之前,Checkbox的 paddingleft 是从View最左侧开始计算的</p>
<p>而Android 4.1.2 之后,Checkbox的 paddingLeft 是从drawableLeft的右侧开始计算起的</p>
<p>2个版本之间的 paddingLeft会差一个 drawableLeft的宽度</p>
<p>一个兼容实现方式</p>
<pre><code>//View hack for fucking difference between versions
        if (Build.VERSION.SDK_INT &amp;lt;= 16) {//4.1.2
            mCheckBox.setPadding(ViewUtils.getPixels(20 + 10, mContext), 0, 0, 0);
            } else {
            mCheckBox.setPadding(ViewUtils.getPixels(10,mContext), 0, 0, 0);
        }
</code></pre><p>讨厌这种写法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-circleanimation-update" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/22/circleanimation-update/" class="article-date">
  	<time datetime="2015-03-22T10:35:39.000Z" itemprop="datePublished">2015-03-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/22/circleanimation-update/">CircleAnimation Update</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/circle_animation_demo2.gif" alt="circle_animation"></p>
<p>修改了实现方式，不再依赖RevealAnimator</p>
<p>也不再依赖</p>
<pre><code>/** @hide */
public void setRevealClip(boolean shouldClip, float x, float y, float radius)&lt;/pre&gt;
</code></pre><p>删除了反射的setRevealClip的部分</p>
<hr>
<p>新的实现完全基于老的Canvas API，兼容低版本</p>
<hr>
<p>缩放的部分加了个bounce效果，不过效果并不好，估计是系数选的不对，看来还是去找一套算好的系数。</p>
<p>最后再把相关接口调整一下，一坨AnimatorSet的嵌套逻辑最后用 playSequentially 整理一下应该就可以结束了。</p>
<hr>
<p>顺带 看了下 CircularReveal <a href="https://github.com/ozodrukh/CircularReveal/" target="_blank" rel="external">https://github.com/ozodrukh/CircularReveal/</a> 的源代码</p>
<p>用这个方案来实现也可以，不过</p>
<p>先draw再clipPath</p>
<p>和</p>
<p>drawCircle with BitmapShader</p>
<p>从结果上来看是完全等价的。</p>
<p>以后需要在ViewGroup上实现该效果可能才用得上这个方案</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a><a class="article-category-link" href="/categories/android/Blog/">Blog</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 DK
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/mobile.js"></script>
<script src="/js/main.js"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>