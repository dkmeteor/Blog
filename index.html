<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>DK&#39;s Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="DK's Lab">
<meta property="og:url" content="http://blog.dk-exp.com/index.html">
<meta property="og:site_name" content="DK's Lab">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DK's Lab">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="DK&#39;s Lab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?47d977b9cd46d5988a3e06ada67a7fa9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://dk-exp.qiniudn.com/logo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">DK</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/dkmeteor" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2699012760" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/ding-ke-53-78" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/circle/" style="font-size: 10px;">circle</a> <a href="/tags/list/" style="font-size: 10px;">list</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">DK</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://dk-exp.qiniudn.com/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">DK</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/dkmeteor" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2699012760" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/ding-ke-53-78" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-android-secondary-sdcard" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/23/android-secondary-sdcard/" class="article-date">
  	<time datetime="2016-05-23T11:01:23.000Z" itemprop="datePublished">2016-05-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/23/android-secondary-sdcard/">android-secondary-sdcard-setting</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前置条件</p>
<p>当Android同时拥有内置存储区和外置SD卡时,外置存储卡会被识别为 <code>Secondary External Storage</code>.<br>本文讨论的是该情况下 <code>Secondart External Storage</code>的识别和读写问题,如果你没有SD卡,或没有内置存储区的设备,只要简单使用<code>Environment.getExternalStorageDirectory()</code> 就好了</p>
<ul>
<li>如何获得外置SD卡路径</li>
</ul>
<p><code>Environment.getExternalStorageDirectory()</code> 获得的只是系统逻辑上的存储区,在目前的大部分手机上,返回的其实是内置存储区路径<br>Google也没有提供一个明确的方法来或者外置存储卡路径.</p>
<p>1.对于Android 4.4 及以上设备使用 <code>Application.getExternalFilesDirs(null)</code>,然后返回的数组中就包含内置存储区路径和SD卡路径,简单判断一下就好了.<br>需要注意的是,返回的路径应当是 /storage/sdcard1/Android/data/your.packagename 的一个路径,在SD卡内,只有该路径下应用是拥有写权限的,其它路径下你都只有只读权限.<br>相关文档请参考这个:<br><a href="https://developer.android.com/reference/android/content/ContextWrapper.html#getExternalFilesDirs(java.lang.String" target="_blank" rel="external">https://developer.android.com/reference/android/content/ContextWrapper.html#getExternalFilesDirs(java.lang.String</a>)</p>
<p>简单来说,4.4以后你就不能在SD卡上瞎几把放东西了,只能存储在系统给你指定的地方</p>
<ol>
<li>对于低于4.4版本的设备,只有一些歪门邪道的方法</li>
</ol>
<p>一种方式是可以通过<code>mount</code>命令的返回来搜索SD卡路径,不是特别靠谱<br>相关代码可以参考 <a href="http://stackoverflow.com/questions/5694933/find-an-external-sd-card-location/9406276#9406276" target="_blank" rel="external">http://stackoverflow.com/questions/5694933/find-an-external-sd-card-location/9406276#9406276</a><br>但是请注意,我看到过4~5种不一样的匹配方法,感觉和manufacture关系很大,国内瞎几把定制ROM不确定性更大,请配合<code>File.canRead()</code>验证使用.</p>
<p>代码贴一下:</p>
<pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;

import android.util.Log;


/**
 * @author ajeet
 *05-Dec-2014  2014
 *
 */
public class StorageUtil {

    public boolean isRemovebleSDCardMounted() {
        File file = new File(&quot;/sys/class/block/&quot;);
        File[] files = file.listFiles(new MmcblkFilter(&quot;mmcblk\\d$&quot;));
        boolean flag = false;
        for (File mmcfile : files) {
            File scrfile = new File(mmcfile, &quot;device/scr&quot;);
            if (scrfile.exists()) {
                flag = true;
                break;
            }
        }
        return flag;
    }

    public String getRemovebleSDCardPath() throws IOException {
        String sdpath = null;
        File file = new File(&quot;/sys/class/block/&quot;);
        File[] files = file.listFiles(new MmcblkFilter(&quot;mmcblk\\d$&quot;));
        String sdcardDevfile = null;
        for (File mmcfile : files) {
            Log.d(&quot;SDCARD&quot;, mmcfile.getAbsolutePath());
            File scrfile = new File(mmcfile, &quot;device/scr&quot;);
            if (scrfile.exists()) {
                sdcardDevfile = mmcfile.getName();
                Log.d(&quot;SDCARD&quot;, mmcfile.getName());
                break;
            }
        }
        if (sdcardDevfile == null) {
            return null;
        }
        FileInputStream is;
        BufferedReader reader;

        files = file.listFiles(new MmcblkFilter(sdcardDevfile + &quot;p\\d+&quot;));
        String deviceName = null;
        if (files.length &gt; 0) {
            Log.d(&quot;SDCARD&quot;, files[0].getAbsolutePath());
            File devfile = new File(files[0], &quot;dev&quot;);
            if (devfile.exists()) {
                FileInputStream fis = new FileInputStream(devfile);
                reader = new BufferedReader(new InputStreamReader(fis));
                String line = reader.readLine();
                deviceName = line;
            }
            Log.d(&quot;SDCARD&quot;, &quot;&quot; + deviceName);
            if (deviceName == null) {
                return null;
            }
            Log.d(&quot;SDCARD&quot;, deviceName);

            final File mountFile = new File(&quot;/proc/self/mountinfo&quot;);

            if (mountFile.exists()) {
                is = new FileInputStream(mountFile);
                reader = new BufferedReader(new InputStreamReader(is));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    // Log.d(&quot;SDCARD&quot;, line);
                    // line = reader.readLine();
                    // Log.d(&quot;SDCARD&quot;, line);
                    String[] mPonts = line.split(&quot;\\s+&quot;);
                    if (mPonts.length &gt; 6) {
                        if (mPonts[2].trim().equalsIgnoreCase(deviceName)) {
                            if (mPonts[4].contains(&quot;.android_secure&quot;)
                                    || mPonts[4].contains(&quot;asec&quot;)) {
                                continue;
                            }
                            sdpath = mPonts[4];
                            Log.d(&quot;SDCARD&quot;, mPonts[4]);

                        }
                    }

                }
            }

        }

        return sdpath;
    }

    static class MmcblkFilter implements FilenameFilter {
        private String pattern;

        public MmcblkFilter(String pattern) {
            this.pattern = pattern;

        }

        @Override
        public boolean accept(File dir, String filename) {
            if (filename.matches(pattern)) {
                return true;
            }
            return false;
        }

    }

}
</code></pre><p>以红米1举例,插入SD卡后,mount返回如下</p>
<pre><code>rootfs / rootfs ro,relatime 0 0
tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,size=437680k,nr_inodes=109420,mode=755 0 0
devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,seclabel,relatime 0 0
selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0
debugfs /sys/kernel/debug debugfs rw,relatime 0 0
none /acct cgroup rw,relatime,cpuacct 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,size=437680k,nr_inodes=109420,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
tmpfs /mnt/asec tmpfs rw,seclabel,relatime,size=437680k,nr_inodes=109420,mode=755,gid=1000 0 0
tmpfs /mnt/obb tmpfs rw,seclabel,relatime,size=437680k,nr_inodes=109420,mode=755,gid=1000 0 0
none /dev/cpuctl cgroup rw,relatime,cpu 0 0
/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,discard,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,discard,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,discard,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
/dev/fuse /storage/emulated/legacy fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
/dev/block/vold/179:65 /mnt/media_rw/sdcard1 vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1023,gid=1023,fmask=0007,dmask=0007,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
/dev/fuse /storage/sdcard1 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
</code></pre><p>可以看到,以上面的字符串匹配或者stackoverflow上其它几种验证方法(asec / vfat / void),都匹配不到最后那条记录</p>
<p>另一种方法:<br>读取 <code>/system/etc/vold.fstab</code></p>
<p>示例代码如下</p>
<pre><code>try {
        Scanner scanner = new Scanner(new File(&quot;/system/etc/vold.fstab&quot;));
        while (scanner.hasNext()) {
            String line = scanner.nextLine();
            if (line.startsWith(&quot;dev_mount&quot;)) {
                String[] lineElements = line.split(&quot; &quot;);
                String element = lineElements[2];

                if (element.contains(&quot;:&quot;))
                    element = element.substring(0, element.indexOf(&quot;:&quot;));

                if (element.contains(&quot;usb&quot;))
                    continue;

                // don&apos;t add the default vold path
                // it&apos;s already in the list.
                if (!out.contains(element))
                    //这里就是你要的SD卡路径了
                    out.add(element);
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre><p>还是以红米1为例,贴一下’/system/etc/vold.fstab’的内容</p>
<pre><code># Copyright (c) 2012, The Linux Foundation. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#     * Neither the name of The Linux Foundation nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

dev_mount sdcard /storage/sdcard1 auto /devices/msm_sdcc.2/mmc_host
</code></pre><p>保险起见,我目前是以上2种方法同时使用,再用<code>file.canRead()</code>检查是否存在</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Android-App-ABI-setting" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/17/Android-App-ABI-setting/" class="article-date">
  	<time datetime="2016-05-17T02:18:43.000Z" itemprop="datePublished">2016-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/17/Android-App-ABI-setting/">Android-App-ABI-setting</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先放结论:<br>最优性能且不考虑安装包体积<br>提供armeabi,armeabi-v7a,arm64-v8a,x86_64</p>
<p>全适配+最小体积<br>提供armeabi,armeabi-v7a</p>
<p>最小体积+99%适配<br>提供armeabi-v7a</p>
<hr>
<p>首先官方的ABI说明<br>ref: <a href="https://developer.android.com/ndk/guides/abis.html" target="_blank" rel="external">https://developer.android.com/ndk/guides/abis.html</a></p>
<p>理想情况下,App应当同时提供armeabi,armeabi-v7a,arm64-v8a,x86,x86_64,mips,mips64的so文件<br>一些比较小的类库提供全部的so以保证在全平台能以最优性能运行,是没有问题的</p>
<p>但是有时候会有一些较大的类库,比如ffmpeg,opencv之类,一个so文件就有3~5mb,全部提供会让APK体积过于膨胀,这个时候就需要进行适当的权衡.</p>
<hr>
<p>不考虑最优性能的话:</p>
<p>其中 x86(x86_32) 的真实设备实际上并不存在,只有模拟器可以调成x86_32,实际存在的CPU都是x86_64的<br>并且,所有x86_64的设备都支持Secondary ABI, 大部分配置都是 armeabi/armeabi-v7a , 不考虑性能最优的话,是可以不提供的</p>
<p>mips略过,印象中只有早期起一些android laptop 是这种架构.</p>
<hr>
<p>这样我们需要实际考虑的ABI只有armeabi,armeabi-v7a,arm64-v8a</p>
<p>考虑最小体积,其实只提供一个armeabi-v7a对于99%的机型就足够了<br>目前就测试结果看<br>只有 MX4 / MX4 PRO 的5.1/5.1.1 会无法找到so文件,猜测可能Primary ABI是 arm64-v8a 并且 Secondary ABI是 armeabi<br>完美的避过了v7a ,当然也有可能是别的原因.目前观察到的只有这款机型有问题</p>
<hr>
<p>之后因为armeabi(实际上是V5)的设备现在市面上几乎已经没有了,考虑兼容,当时尝试使用了v7a+v8a的so,没有提供armeabi版本的so<br>大约也能覆盖98%的设备<br>上线后发现OPPO R7(全系列几乎都有),魅蓝Metal,魅蓝Note,魅族 PRO 5出现大量crash,马上做了hotfix.<br>从数据看,只发生在 Oppo和魅族上,其它机型完全没有.<br>我也很郁闷,这几款机型CPU都是 arm64的,反而找不到v8a的so,具体是个什么情况我不是很理解</p>
<p>就最终结果来看,使用v7a就能覆盖99%的设备(除了魅族 MX4 / MX 4 PRO)<br>为了支持这一设备,再配上个armeabi的so就好了</p>
<hr>
<p>主要观察的数据是应用在umeng后台的错误统计<br>以下是一些测试数据</p>
<p>OPPO R7 V5       OK</p>
<p>OPPO R7 v7 OK</p>
<p>OPPO R7 V5+v7    OK</p>
<p>OPPO R7 V5+v7+V8 OK</p>
<p>OPPO R7 v7+V8 CRASH</p>
<p>OPPO R7 5.0 V7+V8 OK</p>
<p>魅蓝note2 V5   CRASH</p>
<p>魅蓝note2 v7   OK </p>
<p>魅蓝note2 v7+v8   OK</p>
<p>魅蓝note2 V5+v7+v8 OK   </p>
<p>乐视 V5   CRASH</p>
<p>乐视 v7      OK</p>
<p>乐视 v7+v8      OK</p>
<p>乐视 V5+v7+v8    OK</p>
<p>NEXUS 5X V5 CRASH</p>
<p>NEXUS 5X V7 OK</p>
<p>NEXUS 5X V7+V8 OK </p>
<p>PRO 5 V7 CRASH</p>
<p>PRO 5 V7+V8 CRASH</p>
<p>PRO 5 V5 OK</p>
<p>PRO 5 V5+V7+V8 OK</p>
<p>GALAXY S6 V7 OK</p>
<p>GALAXY S6 V5+V7 OK</p>
<p>最终方案使用 v5+v7,v8a以兼容模式运行32位库<br>以下设备测试没问题.</p>
<p>OPPO R7 OK</p>
<p>三星 S6 OK</p>
<p>华为 mate S OK</p>
<p>魅蓝note2 OK</p>
<p>魅族 PRO 5 OK</p>
<p>nexus 5X OK</p>
<p>小米4C OK</p>
<p>乐视手机 OK</p>
<p>nexus 5 OK</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Mediaplayer-ConfigPriority-0x6f800002-ERROR-on-Marshmallow" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/22/Mediaplayer-ConfigPriority-0x6f800002-ERROR-on-Marshmallow/" class="article-date">
  	<time datetime="2016-04-22T07:59:30.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/Mediaplayer-ConfigPriority-0x6f800002-ERROR-on-Marshmallow/">Mediaplayer ConfigPriority(0x6f800002)) ERROR on Marshmallow</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Mediaplayer ConfigPriority(0x6f800002)) ERROR on Marshmallow</p>
<p>Android 6.0 使用源生MediaPlayer播放小于15s的音频文件时,有可能会抛出此错误 ConfigPriority(0x6f800002))<br>不会crash,但是没有声音</p>
<p>log:</p>
<pre><code>04-21 16:42:11.787 745-21846/? I/QComExtractorFactory: Sniff: Set key to use qti parser
04-21 16:42:11.787 745-21846/? I/FFmpegExtractor: android-source:0xee977200
04-21 16:42:11.790 745-21846/? E/FFmpegExtractor: android-source:0xee977200: avformat_open_input failed, err:Invalid data found when processing input
04-21 16:42:11.790 745-21846/? W/FFmpegExtractor: sniff through BetterSniffFFMPEG failed, try LegacySniffFFMPEG
04-21 16:42:11.793 745-21846/? E/FFmpegExtractor: android-source:0xee977200|file:: avformat_open_input failed, err:Invalid data found when processing input
04-21 16:42:11.793 745-21846/? D/FFmpegExtractor: SniffFFMPEG failed to sniff this source
04-21 16:42:11.793 745-21846/? I/ExtendedExtractor: QTIParser is prefered
04-21 16:42:11.793 745-21846/? D/MMParserExtractor: setExtraFlags called with flags 3 for paser instance ee977340
04-21 16:42:11.793 745-21846/? D/MMParserExtractor: using bigger parser buffers
04-21 16:42:11.793 745-21846/? I/ExtendedExtractor: ExtendedExtractor::create 0xee977340
04-21 16:42:11.793 745-21846/? I/ExtendedExtractor: ExtendedExtractor::updateExtractor: Use default QTI parser 
04-21 16:42:11.793 745-21846/? D/MMParserExtractor: Overiding Parser out buffer size  = 262144 
04-21 16:42:11.794 745-21845/? D/NuPlayerDriver: notifyListener_l(0xefee20a0), (1, 0, 0)
04-21 16:42:11.796 745-3258/? D/NuPlayerDriver: start(0xefee20a0), state is 4, eos is 0
04-21 16:42:11.796 745-21845/? I/GenericSource: start
04-21 16:42:11.797 745-21845/? I/AudioPolicyManagerCustom: Offload min duration is 15s
04-21 16:42:11.797 745-21845/? I/AudioPolicyManagerCustom: PCM offload property is enabled
04-21 16:42:11.797 745-21845/? I/AudioPolicyManagerCustom: Offload min duration is 15s
04-21 16:42:11.798 745-21845/? I/AudioPolicyManagerCustom: Offload min duration is 15s
04-21 16:42:11.798 745-21845/? I/AudioPolicyManagerCustom: PCM offload property is enabled
04-21 16:42:11.798 745-21845/? I/AudioPolicyManagerCustom: Offload min duration is 15s
04-21 16:42:11.812 745-21850/? E/OMXNodeInstance: setConfig(21f:google.aac.decoder, ConfigPriority(0x6f800002)) ERROR: Undefined(0x80001001)
04-21 16:42:11.812 745-21850/? I/ACodec: codec does not support config priority (err -2147483648)
04-21 16:42:11.813 745-21850/? I/MediaCodec: MediaCodec will operate in async mode
04-21 16:42:11.814 745-21851/? I/SoftAAC2: Reconfiguring decoder: 0-&gt;44100 Hz, 0-&gt;0 channels
04-21 16:42:11.815 745-21851/? W/SoftAAC2: aacDecoder_DecodeFrame decoderErr = 0x4007
04-21 16:42:11.815 745-21851/? W/SoftAAC2: AAC decoder returned error 0x4007, substituting silence
04-21 16:42:11.816 745-21849/? I/NuPlayerDecoder: [audio] saw output EOS
04-21 16:42:11.816 745-21845/? I/ExtendedNuPlayer: notifyListener 2 0 0
04-21 16:42:11.816 745-21845/? D/NuPlayerDriver: notifyListener_l(0xefee20a0), (2, 0, 0)
04-21 16:42:11.816 745-21848/? W/NuPlayerRenderer: onDrainAudioQueue(): audio sink is not ready
</code></pre><p>google issue已经确认了此Bug,目前处在assign状态,不过在6.0.1上测试时已经正常.</p>
<p>ref <a href="https://code.google.com/p/android/issues/detail?id=189051" target="_blank" rel="external">google issue</a> [需翻墙]</p>
<p>从log和更新记录上看,猜测似乎是offload的影响</p>
<pre><code>av.offload.enable=true 
av.streaming.offload.enable=true 
audio.offload.buffer.size.kb=64 
audio.offload.min.duration.secs=30 
audio.offload.gapless.enabled=true 
audio.offload.pcm.16bit.enable=true 
audio.offload.pcm.24bit.enable=true
</code></pre><p>从源码上看 似乎针对不同长度的音频文件 ,根据offload.enable和offload.min.duration,会有不同的处理方式</p>
<p>Audio Offload 音频分载, 具体代码逻辑没有细看,也不大清楚具体错误原因</p>
<p>目前唯一已知解决方案是,降级到5.0或升级到6.0.1+</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-CoordinatorLayout" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/30/CoordinatorLayout/" class="article-date">
  	<time datetime="2016-03-30T01:56:02.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/CoordinatorLayout/">CoordinatorLayout中的坑</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>踩完了坑记录一下，CoordinatorLayout使用介绍请看chrisbanes的<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="external">cheesesquare</a></p>
<p>如果你只打算学习一下CoordinatorLayout然后写2个Demo试试，那么本文并没有什么卵用，但是如果你打算在生产环境使用CoordinatorLayout，那么强烈推荐阅读一下本文，可以减少很多弯路，这个东西看起来很好，但是实际上坑也很多。</p>
<p>###前言<br>很多应用主页常见的构造模式</p>
<p>一个包含ActionBar和Banner的header+ViewPager的组合模式<br>比如这样：</p>
<p><img src="/images/appbar_extend.png" alt="img"></p>
<p>然后需要滚动的时候能够将 ActionBar和Banner滚出界面，但是又需要ViewPager的TabLayout能固定在屏幕顶部<br>比如滚动后是这样：</p>
<p><img src="/images/appbar_close.png" alt="img"></p>
<p>Github上有很多sticky-viewpager xx-header-viewpager之类的项目提供类似的功能，但是大部分都会存在各种事件冲突问题，比如滑动不流畅，卡顿，弹跳之类的。</p>
<p>好在Android新的SupportLibrary提供了CoordinatorLayout能直接实现类似功能，具体如何使用参考 SupportLibrary中CoordinatorLayout的使用文档即可，例子也可以直接看<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="external">cheesesquare</a></p>
<p>我就谈下使用过程中里面的坑：</p>
<h4 id="不支持ListView-不支持ScrollView，低版本不兼容ViewCompat-setNestedScrollingEnabled"><a href="#不支持ListView-不支持ScrollView，低版本不兼容ViewCompat-setNestedScrollingEnabled" class="headerlink" title="不支持ListView,不支持ScrollView，低版本不兼容ViewCompat.setNestedScrollingEnabled"></a>不支持ListView,不支持ScrollView，低版本不兼容ViewCompat.setNestedScrollingEnabled</h4><p>PS.更新</p>
<p>support 23.1+新增了</p>
<pre><code>ViewCompat.setNestedScrollingEnabled(listView/gridview,true); 
</code></pre><p>可以给ListView提供NestedScrolling支持,但是只在LOLIPOP+版本上生效，下面的方案也一样。</p>
<p>低版本只能使用RecyclerView</p>
<hr>
<p>一些文档/博客文章上说 可以使用一个 可滚动的组件<br>还有些错误的文章说 支持ListView</p>
<p>实际上该组件必须实现了 NestedScrollingChild接口</p>
<p>你可以使用RecyclerView,RecyclerView自身就实现了该接口，如果你要使用其他组件，那么可能需要继承原来的View并实现NestedScrollingChild接口</p>
<p>一个实现了NestedScrollingChild的Listview demo如下：</p>
<pre><code>public class NestedScrollingListView extends ListView implements NestedScrollingChild {

    private final NestedScrollingChildHelper mScrollingChildHelper;

    public NestedScrollingListView(Context context) {
        super(context);
        mScrollingChildHelper = new NestedScrollingChildHelper(this);
        setNestedScrollingEnabled(true);
    }

    public NestedScrollingListView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mScrollingChildHelper = new NestedScrollingChildHelper(this);
        setNestedScrollingEnabled(true);
    }

    @Override
    public void setNestedScrollingEnabled(boolean enabled) {
        mScrollingChildHelper.setNestedScrollingEnabled(enabled);
    }

    @Override
    public boolean isNestedScrollingEnabled() {
        return mScrollingChildHelper.isNestedScrollingEnabled();
    }

    @Override
    public boolean startNestedScroll(int axes) {
        return mScrollingChildHelper.startNestedScroll(axes);
    }

    @Override
    public void stopNestedScroll() {
        mScrollingChildHelper.stopNestedScroll();
    }

    @Override
    public boolean hasNestedScrollingParent() {
        return mScrollingChildHelper.hasNestedScrollingParent();
    }

    @Override
    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed,
                                        int dyUnconsumed, int[] offsetInWindow) {
        return mScrollingChildHelper.dispatchNestedScroll(dxConsumed, dyConsumed,
                dxUnconsumed, dyUnconsumed, offsetInWindow);
    }

    @Override
    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) {
        return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);
    }

    @Override
    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) {
        return mScrollingChildHelper.dispatchNestedFling(velocityX, velocityY, consumed);
    }

    @Override
    public boolean dispatchNestedPreFling(float velocityX, float velocityY) {
        return mScrollingChildHelper.dispatchNestedPreFling(velocityX, velocityY);
    }
}
</code></pre><p>其他View也可以使用类似的方式实现。</p>
<p>只对 5.0+ 生效，低版本无效。</p>
<h4 id="RecyclerView滑动的时候不流畅"><a href="#RecyclerView滑动的时候不流畅" class="headerlink" title="RecyclerView滑动的时候不流畅"></a>RecyclerView滑动的时候不流畅</h4><p>目前已知 r23.1 &amp; r 23.2  都存在此问题，Google code的提交代码里倒是有相关修复记录，但是目前还没有发布。</p>
<p>直接原因是Fling Direction错误，导致Fling事件被吃掉了，ACTION_UP/ACTION_CANCEL事件一旦发生，scroll动作直接停止</p>
<p>StackOverFlow上一个高票解决方案是重写一个FlingBehavior，并配置给AppBar.</p>
<p>注意，这个Behavior是给AppBar的，不是给下面的可滚动组件的。</p>
<pre><code>&lt;android.support.design.widget.AppBarLayout
android:id=&quot;@+id/appbar&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
app:layout_behavior=&quot;your.package.FlingBehavior&quot;&gt;
&lt;!--your views here--&gt;
 &lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre><hr>
<pre><code>public class FlingBehavior extends AppBarLayout.Behavior {

    private static final int TOP_CHILD_FLING_THRESHOLD = 3;
    private boolean isPositive;

    public FlingBehavior() {
    }

    public FlingBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean onNestedFling(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, float velocityX, float velocityY, boolean consumed) {
        if (velocityY &gt; 0 &amp;&amp; !isPositive || velocityY &lt; 0 &amp;&amp; isPositive) {
            velocityY = velocityY * -1;
        }
        if (target instanceof RecyclerView &amp;&amp; velocityY &lt; 0) {
            final RecyclerView recyclerView = (RecyclerView) target;
            final View firstChild = recyclerView.getChildAt(0);
            final int childAdapterPosition = recyclerView.getChildAdapterPosition(firstChild);
            consumed = childAdapterPosition &gt; TOP_CHILD_FLING_THRESHOLD;
        }
        consumed=false;
        return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed);
    }

    @Override
    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dx, int dy, int[] consumed) {
        super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);
        isPositive = dy &gt; 0;
    }
</code></pre><p>注意consumed计算这部分，会影响滚动形式</p>
<p>请参考父类滚动的实现代码：</p>
<pre><code> @Override
public boolean onNestedFling(final CoordinatorLayout coordinatorLayout,
            final AppBarLayout child, View target, float velocityX, float velocityY,
            boolean consumed) {
        boolean flung = false;

        if (!consumed) {
            // It has been consumed so let&apos;s fling ourselves
            flung = fling(coordinatorLayout, child, -child.getTotalScrollRange(),
                    0, -velocityY);
        } else {
            // If we&apos;re scrolling up and the child also consumed the fling. We&apos;ll fake scroll
            // upto our &apos;collapsed&apos; offset
            if (velocityY &lt; 0) {
                // We&apos;re scrolling down
                final int targetScroll = -child.getTotalScrollRange()
                        + child.getDownNestedPreScrollRange();
                if (getTopBottomOffsetForScrollingSibling() &lt; targetScroll) {
                    // If we&apos;re currently not expanded more than the target scroll, we&apos;ll
                    // animate a fling
                    animateOffsetTo(coordinatorLayout, child, targetScroll);
                    flung = true;
                }
            } else {
                // We&apos;re scrolling up
                final int targetScroll = -child.getUpNestedPreScrollRange();
                if (getTopBottomOffsetForScrollingSibling() &gt; targetScroll) {
                    // If we&apos;re currently not expanded less than the target scroll, we&apos;ll
                    // animate a fling
                    animateOffsetTo(coordinatorLayout, child, targetScroll);
                    flung = true;
                }
            }
        }

        mWasNestedFlung = flung;
        return flung;
    }
</code></pre><p>确认你需要滚动哪一步分，你可以简单根据RecyclerView展示的first item的position来判断Recyclerview是否在top位置，也有另一种代码如下：</p>
<pre><code>@Override
public boolean onNestedFling(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, float velocityX, float velocityY, boolean consumed) {
    if (target instanceof RecyclerView) {
        final RecyclerView recyclerView = (RecyclerView) target;
        consumed = velocityY &gt; 0 || recyclerView.computeVerticalScrollOffset() &gt; 0;
    }
    return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed);
}
</code></pre><p>另一个解决方案是使用 <a href="https://github.com/henrytao-me/smooth-app-bar-layout" target="_blank" rel="external">smooth-app-bar-layout</a></p>
<p>具体如何使用请参考它自己的文档</p>
<p>当header是Toolbar时，demo运作良好，当headerview高度较大时，滑动会发生剧烈抖动，弹跳，暂时还没去看它源代码，可能是我使用不正确</p>
<h4 id="不支持adjustResize"><a href="#不支持adjustResize" class="headerlink" title="不支持adjustResize"></a>不支持adjustResize</h4><p>可以参考这个问题<br><a href="http://stackoverflow.com/questions/35599125/adjustresize-does-not-work-with-coordinatorlayout" target="_blank" rel="external">http://stackoverflow.com/questions/35599125/adjustresize-does-not-work-with-coordinatorlayout</a></p>
<p>解决方案是可以通过ViewTreeObserver.OnGlobalLayoutListener监听界面改变，然后人工处理padding bottom</p>
<pre><code>public class KeyboardUtil {
    private View decorView;
    private View contentView;

    public KeyboardUtil(Activity act, View contentView) {
        this.decorView = act.getWindow().getDecorView();
        this.contentView = contentView;

        //only required on newer android versions. it was working on API level 19
        if (Build.VERSION.SDK_INT &gt;= 19) {
            decorView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener);
        }
    }

    public void enable() {
        if (Build.VERSION.SDK_INT &gt;= 19) {
            decorView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener);
        }
    }

    public void disable() {
        if (Build.VERSION.SDK_INT &gt;= 19) {
            decorView.getViewTreeObserver().removeOnGlobalLayoutListener(onGlobalLayoutListener);
        }
    }


    //a small helper to allow showing the editText focus
    ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            Rect r = new Rect();
            //r will be populated with the coordinates of your view that area still visible.
            decorView.getWindowVisibleDisplayFrame(r);

            //get screen height and calculate the difference with the useable area from the r
            int height = decorView.getContext().getResources().getDisplayMetrics().heightPixels;
            int diff = height - r.bottom;

            //if it could be a keyboard add the padding to the view
            if (diff != 0) {
                // if the use-able screen height differs from the total screen height we assume that it shows a keyboard now
                //check if the padding is 0 (if yes set the padding for the keyboard)
                if (contentView.getPaddingBottom() != diff) {
                    //set the padding of the contentView for the keyboard
                    contentView.setPadding(0, 0, 0, diff);
                }
            } else {
                //check if the padding is != 0 (if yes reset the padding)
                if (contentView.getPaddingBottom() != 0) {
                    //reset the padding of the contentView
                    contentView.setPadding(0, 0, 0, 0);
                }
            }
        }
    };


    /**
     * Helper to hide the keyboard
     *
     * @param act
     */
    public static void hideKeyboard(Activity act) {
        if (act != null &amp;&amp; act.getCurrentFocus() != null) {
            InputMethodManager inputMethodManager = (InputMethodManager) act.getSystemService(Activity.INPUT_METHOD_SERVICE);
            inputMethodManager.hideSoftInputFromWindow(act.getCurrentFocus().getWindowToken(), 0);
        }
    }
}
</code></pre><hr>
<pre><code>KeyboardUtil keyboardUtil = new KeyboardUtil(this, findViewById(android.R.id.content));

//enable it
keyboardUtil.enable();
</code></pre><hr>
<p>ps.<br>fitSystemWindow 和 adjustResize 和 FLAG_TRANSLUCENT_STATUS 一起使用 一样也会有冲突，造成界面缩放不正常。  当时也是用的这个解决方案。</p>
<h3 id="CoordinatorLayout的onScrollListener只支持21"><a href="#CoordinatorLayout的onScrollListener只支持21" class="headerlink" title="CoordinatorLayout的onScrollListener只支持21+"></a>CoordinatorLayout的onScrollListener只支持21+</h3><p>解决方案：<br>在Behavior里监听滚动，并把数据传出来</p>
<p>代码和后一个问题贴在一起</p>
<p>注意 我这里只监听了 onDependentViewChanged<br>并在这里调用onScroll接口，然后外部实际使用的数据是 headerview.getTop , 并不能覆盖全部情况，但是我本身只用来做状态栏渐变色，有其它使用场景请自行修改</p>
<h3 id="当顶部容器不使用Toolbar时，Measure会有问题"><a href="#当顶部容器不使用Toolbar时，Measure会有问题" class="headerlink" title="当顶部容器不使用Toolbar时，Measure会有问题"></a>当顶部容器不使用Toolbar时，Measure会有问题</h3><p>解决方案：<br>自定义一个 Behavior,继承AppBarLayout.ScrollingViewBehavior</p>
<p>并重载onMeasureChild方法</p>
<pre><code>public class PatchedScrollingViewBehavior extends AppBarLayout.ScrollingViewBehavior {

    private OnScrollListener onScrollListener;

    public PatchedScrollingViewBehavior() {
        super();
    }

    public PatchedScrollingViewBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {

        Log.e(&quot;####&quot;, &quot;onMeasureChild&quot;);


        if (child.getLayoutParams().height == -1) {
            List dependencies = parent.getDependencies(child);
            if (dependencies.isEmpty()) {
                return false;
            }

            AppBarLayout appBar = findFirstAppBarLayout(dependencies);
            if (appBar != null &amp;&amp; ViewCompat.isLaidOut(appBar)) {
                if (ViewCompat.getFitsSystemWindows(appBar)) {
                    ViewCompat.setFitsSystemWindows(child, true);
                }

                int scrollRange = appBar.getTotalScrollRange();
//                int height = parent.getHeight() - appBar.getMeasuredHeight() + scrollRange;
                int parentHeight = View.MeasureSpec.getSize(parentHeightMeasureSpec);
                int height = parentHeight - appBar.getMeasuredHeight() + scrollRange;
                int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.AT_MOST);
                parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed);
                return true;
            }
        }

        return false;
    }

    @Override
    public void onNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) {
        super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);
    }

    private static AppBarLayout findFirstAppBarLayout(List&lt;View&gt; views) {
        int i = 0;
        for (int z = views.size(); i &lt; z; ++i) {
            View view = (View) views.get(i);
            if (view instanceof AppBarLayout) {
                return (AppBarLayout) view;
            }
        }
        return null;
    }

    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, View child,
                                          View dependency) {
        if (onScrollListener != null) {
            onScrollListener.onScroll(parent, child, dependency);
        }
        return super.onDependentViewChanged(parent, child, dependency);
    }

    public interface OnScrollListener {
        void onScroll(CoordinatorLayout parent, View child,
                      View dependency);

    }

    public OnScrollListener getOnScrollListener() {
        return onScrollListener;
    }

    public void setOnScrollListener(OnScrollListener onScrollListener) {
        this.onScrollListener = onScrollListener;
    }
}
</code></pre><p>REF:<br><a href="http://stackoverflow.com/questions/30923889/flinging-with-recyclerview-appbarlayout" target="_blank" rel="external">http://stackoverflow.com/questions/30923889/flinging-with-recyclerview-appbarlayout</a><br><a href="https://github.com/henrytao-me/smooth-app-bar-layout" target="_blank" rel="external">https://github.com/henrytao-me/smooth-app-bar-layout</a><br><a href="https://code.google.com/p/android/issues/detail?id=177729" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=177729</a> </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-MVC-MVP-MVVM" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/MVC-MVP-MVVM/" class="article-date">
  	<time datetime="2015-12-21T00:15:11.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/MVC-MVP-MVVM/">MVC &amp; MVP &amp; MVVM</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#MVC &amp; MVP &amp; MVVP</p>
<p>先放2个引用，概念上的讨论我觉得可以参考这2个。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>
<p><a href="http://weibo.com/p/1001603808855434892996" target="_blank" rel="external">http://weibo.com/p/1001603808855434892996</a>  </p>
<p>我主要想讨论下 这一演化过程,和架构选择的必要性。</p>
<p>###MVC</p>
<p>首先，传统的MVC项目中，layout.xml承担View的角色，Activity承担Controller的角色。</p>
<p>这本身没有什么问题，如果你的Activity代码不足千行（当然不包含网络请求及解析），多拆分几个方法，写好注释，也可以一用。<br>你也可以通过把其中部分逻辑 模块化抽出的方式 简化Activity代码。很多小型项目或者功能简单的Activity，使用MVC模型就可以了，盲目的使用MVP或MVVM并不是好事。</p>
<p>###MVP</p>
<p>然而随着项目的不断发展和复杂化，Activity承担的内容越来越多，请求数据，响应数据，数据处理，生成UI，修改view的状态，特效实现。</p>
<p>当Activity过于膨胀，我们就需要拆分它。</p>
<p>按职责，拆分为 <code>业务逻辑</code> 和 <code>UI逻辑</code>，就是Android中当前推荐的MVP实现.</p>
<ul>
<li><p>业务逻辑</p>
<p>  包含请求数据，响应操作，对数据的处理等等业务相关的代码。</p>
</li>
<li><p>UI逻辑</p>
<p>  包含界面的调整，UI状态的变化，动效等。</p>
</li>
</ul>
<p>业务逻辑通过抽出 Presenter 层实现。<br>UI逻辑通过构造 ViewInterface并由Activity实现。</p>
<p>由于View和Presenter仅通过  ViewInterface关联，单独修改View或Presenter不会互相影响。</p>
<p>这是个好事，一般工程上小的UI调整总是多如牛毛，避免其影响到业务逻辑层可以减少很多bug的产生。</p>
<p>反过来也是一样。</p>
<p>当然，坏处也有，当你的Presenter需要添加一个新的功能/行为时，你需要在ViewInterface上添加新的接口，并在Activity上实现。<br>更多的灵活性总是意味着 更复杂的项目层次。</p>
<p>如果你遇到2种问题，那么你应当使用MVP</p>
<ol>
<li>你需要自动化测试。</li>
</ol>
<p>MVP的引入会让测试变得非常方便。<br>写一个简单的包含mock数据的Presenter就可以测试所有UI逻辑。<br>可以非常方便的在没有后端的情况下完成所有UI层逻辑及测试</p>
<p>同时 Presenter的测试也变得容易，因为Presenter现在与View是完全分离的，这意味着，测试业务逻辑时，你甚至不需要Android 环境，而且可以简单的mock ui行为。<br>这可比用脚本在模拟器上跑测试要方便多了。</p>
<ol>
<li>更高的复用率</li>
</ol>
<p>Activity或Presenter都可以复用。如果你的项目需要快速迭代，那往往意味着，大量的UI变更，大量的逻辑调整。<br>分离Activity和Presenter可以减少很多 因为互相影响产生的bug，而且页面和逻辑变得方便调整和复用。</p>
<p>###MVVM</p>
<p>Android上谈MVVM，目前大多是指data binding.<br>这个东西刚出来的时候还比较火，但是实际用起来坑还比较多，目前没有看到哪个大型项目有实践这个东西。</p>
<p>具体使用可以参考这个文档  <a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">MasteringAndroidDataBinding</a> 。<br>看起来不错，用起来都是坑。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-weak-handler" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/11/weak-handler/" class="article-date">
  	<time datetime="2015-11-11T04:08:47.000Z" itemprop="datePublished">2015-11-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/11/weak-handler/">Weak Handler 与 内存泄露</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Weak Handler 与 内存泄露</p>
<p>Handler使用不当比较容易造成内存泄露.</p>
<p>比如这个例子:<a href="http://www.jianshu.com/p/c49f778e7acf" target="_blank" rel="external">http://www.jianshu.com/p/c49f778e7acf</a></p>
<p>通常的原因就是 Handler的生命周期和Activity的生命周期不一致.</p>
<hr>
<p>一个通用的场景是 使用 匿名内部类 实例 作为某个 行为/动作的 回调,如果该行为/动作 是异步的,则其返回时间往往无法确定,有造成内存泄露风险.</p>
<p>使用静态内部类,或者妥善处理生命周期,都不会造成内存泄露,反过来,当没有内存泄露风险时,一般直接匿名内部类即可.</p>
<p>这其实是一个特别矛盾的说法.</p>
<p>因为这要求程序员能 能了解到 回调行为是在何时发生的. </p>
<p>而相反,我们设计接口回调的时候总是尽力屏蔽内部实现细节.</p>
<p>而面对不确定的行为,当然也可以使用静态内部类,或者removeCallback去取消回调(特指Handler),然而这样代码变得繁琐,或者添加不必要的代码.</p>
<p>对于Handler,一个简单的第三方解决方案是使用 android-weak-handler ,该库尝试使用WeakReference解决这个问题,然而却引入新的问题.</p>
<p><a href="https://github.com/badoo/android-weak-handler" target="_blank" rel="external">https://github.com/badoo/android-weak-handler</a></p>
<p>核心代码如下:</p>
<pre><code>public class WeakHandler {
    private final Handler.Callback mCallback; // hard reference to Callback. We need to keep callback in memory
    private final ExecHandler mExec;
    private Lock mLock = new ReentrantLock();
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    @VisibleForTesting
    final ChainedRef mRunnables = new ChainedRef(mLock, null);

    public WeakHandler() {
        mCallback = null;
        mExec = new ExecHandler();
    }

    public WeakHandler(@Nullable Handler.Callback callback) {
        mCallback = callback; // Hard referencing body
        mExec = new ExecHandler(new WeakReference&lt;&gt;(callback)); // Weak referencing inside ExecHandler
    }

    public WeakHandler(@NonNull Looper looper) {
        mCallback = null;
        mExec = new ExecHandler(looper);
    }

    public WeakHandler(@NonNull Looper looper, @NonNull Handler.Callback callback) {
        mCallback = callback;
        mExec = new ExecHandler(looper, new WeakReference&lt;&gt;(callback));
    }

    public final boolean post(@NonNull Runnable r) {
        return mExec.post(wrapRunnable(r));
    }

    public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) {
        return mExec.postAtTime(wrapRunnable(r), uptimeMillis);
    }

    public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) {
        return mExec.postAtTime(wrapRunnable(r), token, uptimeMillis);
    }

    public final boolean postDelayed(Runnable r, long delayMillis) {
        return mExec.postDelayed(wrapRunnable(r), delayMillis);
    }

    public final boolean postAtFrontOfQueue(Runnable r) {
        return mExec.postAtFrontOfQueue(wrapRunnable(r));
    }

    public final void removeCallbacks(Runnable r) {
        final WeakRunnable runnable = mRunnables.remove(r);
        if (runnable != null) {
            mExec.removeCallbacks(runnable);
        }
    }

    public final void removeCallbacks(Runnable r, Object token) {
        final WeakRunnable runnable = mRunnables.remove(r);
        if (runnable != null) {
            mExec.removeCallbacks(runnable, token);
        }
    }

    public final boolean sendMessage(Message msg) {
        return mExec.sendMessage(msg);
    }

    public final boolean sendEmptyMessage(int what) {
        return mExec.sendEmptyMessage(what);
    }

    public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
        return mExec.sendEmptyMessageDelayed(what, delayMillis);
    }

    public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {
        return mExec.sendEmptyMessageAtTime(what, uptimeMillis);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis) {
        return mExec.sendMessageDelayed(msg, delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        return mExec.sendMessageAtTime(msg, uptimeMillis);
    }

    public final boolean sendMessageAtFrontOfQueue(Message msg) {
        return mExec.sendMessageAtFrontOfQueue(msg);
    }

    public final void removeMessages(int what) {
        mExec.removeMessages(what);
    }

    public final void removeMessages(int what, Object object) {
        mExec.removeMessages(what, object);
    }

    public final void removeCallbacksAndMessages(Object token) {
        mExec.removeCallbacksAndMessages(token);
    }

    public final boolean hasMessages(int what) {
        return mExec.hasMessages(what);
    }

    public final boolean hasMessages(int what, Object object) {
        return mExec.hasMessages(what, object);
    }

    public final Looper getLooper() {
        return mExec.getLooper();
    }

    private WeakRunnable wrapRunnable(@NonNull Runnable r) {
        //noinspection ConstantConditions
        if (r == null) {
            throw new NullPointerException(&quot;Runnable can&apos;t be null&quot;);
        }
        final ChainedRef hardRef = new ChainedRef(mLock, r);
        mRunnables.insertAfter(hardRef);
        return hardRef.wrapper;
    }

    private static class ExecHandler extends Handler {
        private final WeakReference&lt;Handler.Callback&gt; mCallback;

        ExecHandler() {
            mCallback = null;
        }

        ExecHandler(WeakReference&lt;Handler.Callback&gt; callback) {
            mCallback = callback;
        }

        ExecHandler(Looper looper) {
            super(looper);
            mCallback = null;
        }

        ExecHandler(Looper looper, WeakReference&lt;Handler.Callback&gt; callback) {
            super(looper);
            mCallback = callback;
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            if (mCallback == null) {
                return;
            }
            final Handler.Callback callback = mCallback.get();
            if (callback == null) { // Already disposed
                return;
            }
            callback.handleMessage(msg);
        }
    }

    static class WeakRunnable implements Runnable {
        private final WeakReference&lt;Runnable&gt; mDelegate;
        private final WeakReference&lt;ChainedRef&gt; mReference;

        WeakRunnable(WeakReference&lt;Runnable&gt; delegate, WeakReference&lt;ChainedRef&gt; reference) {
            mDelegate = delegate;
            mReference = reference;
        }

        @Override
        public void run() {
            final Runnable delegate = mDelegate.get();
            final ChainedRef reference = mReference.get();
            if (reference != null) {
                reference.remove();
            }
            if (delegate != null) {
                delegate.run();
            }
        }
    }

    static class ChainedRef {
        @Nullable
        ChainedRef next;
        @Nullable
        ChainedRef prev;
        @NonNull
        final Runnable runnable;
        @NonNull
        final WeakRunnable wrapper;

        @NonNull
        Lock lock;

        public ChainedRef(@NonNull Lock lock, @NonNull Runnable r) {
            this.runnable = r;
            this.lock = lock;
            this.wrapper = new WeakRunnable(new WeakReference&lt;&gt;(r), new WeakReference&lt;&gt;(this));
        }

        public WeakRunnable remove() {
            lock.lock();
            try {
                if (prev != null) {
                    prev.next = next;
                }
                if (next != null) {
                    next.prev = prev;
                }
                prev = null;
                next = null;
            } finally {
                lock.unlock();
            }
            return wrapper;
        }

        public void insertAfter(@NonNull ChainedRef candidate) {
            lock.lock();
            try {
                if (this.next != null) {
                    this.next.prev = candidate;
                }

                candidate.next = this.next;
                this.next = candidate;
                candidate.prev = this;
            } finally {
                lock.unlock();
            }
        }

        @Nullable
        public WeakRunnable remove(Runnable obj) {
            lock.lock();
            try {
                ChainedRef curr = this.next; // Skipping head
                while (curr != null) {
                    if (curr.runnable == obj) { // We do comparison exactly how Handler does inside
                        return curr.remove();
                    }
                    curr = curr.next;
                }
            } finally {
                lock.unlock();
            }
            return null;
        }
    }
}
</code></pre><p>这个类的实现有个问题,为了避免持有Runnable的引用,使用WeakRunnable作为Wrapper,为了能够在Activity销毁时释放Runnable,这里使用的WeakReference去持有Runnable引用.<br>从目的上看,它确实解决了由于Runnable隐式持有Activity强引用而导致Acticity实例无法销毁的问题</p>
<p>##但是</p>
<p>作为匿名内部类被传入的Runnable对象如果只存在一个WeakReference,那意味着,任何一次GC操作都将导致其被回收.<br>看看这个例子</p>
<pre><code>import com.badoo.mobile.util.WeakHandler;

public class ExampleActivity extends Activity {

    private WeakHandler mHandler; // We still need at least one hard reference to WeakHandler

    protected void onCreate(Bundle savedInstanceState) {
        mHandler = new WeakHandler();
        ...
    }

    private void onClick(View view) {
        mHandler.postDelayed(new Runnable() {
            view.setVisibility(View.INVISIBLE);
        }, 5000);
    }
}
</code></pre><p>如果在这5s内系统触发了一次GC操作会怎么样? Runnable会被回收?</p>
<p>将Demo简单修改一下</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    WeakHandler  mHandler = new WeakHandler();
    mHandler.postDelayed(new Runnable() {


        @Override
        public void run() {
            System.out.println(&quot;####################### Do Something&quot;);
            );
        }
    }, 10000);

    mHandler.postDelayed(new Runnable() {


        @Override
        public void run() {
            System.out.println(&quot;#######################GC&quot;);

            System.gc();
        }
    }, 5000);

}
</code></pre><p>看看运行结果,GC操作发生了,而Do Something并没有执行,因为 GC动作发生时, WeakReference持有的Runnable已经被释放了.</p>
<p>通常来讲,GC操作发生的时间不可预料的,你无法预期等待回调的这几秒种内用户做了什么操作,而一旦触发了GC,则回调会被立刻取消</p>
<p>注意,Activity并未被关闭,Runnable回调也会被释放!</p>
<p>如果在大型项目中遇到这样的问题,排查一定是灾难性的.因为GC的不确定性,出现了回调丢失情况一定是随机的,难以预测的,难以重现的.</p>
<p>而处理这个问题的办法是,将mHandler从临时变量 换成 成Activity的一个实例变量.</p>
<p>然而通常程序员不一定意识这2种写法的区别,而且使用系统提供的Handler时,这2种写法是没有区别的.</p>
<p>最后我检查了下文档,作者还是写了一句话作为提示</p>
<blockquote>
<p>We still need at least one hard reference to WeakHandler</p>
</blockquote>
<p>至于使用者是否能意识到问题所在我持怀疑态度.</p>
<p>第三方库就是容易出现这种问题,使用起来能很方便的解决很多问题,然而又很容易挖几个隐蔽的坑给你.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-PreLoadHack" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/28/PreLoadHack/" class="article-date">
  	<time datetime="2015-10-27T23:06:13.000Z" itemprop="datePublished">2015-10-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/28/PreLoadHack/">PreLoadHack</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android换肤技术-PreLoad-Hack"><a href="#Android换肤技术-PreLoad-Hack" class="headerlink" title="Android换肤技术 PreLoad Hack"></a>Android换肤技术 PreLoad Hack</h1><p>参考 <a href="http://blog.zhaiyifan.cn/2015/09/10/Android%E6%8D%A2%E8%82%A4%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">Android换肤技术总结</a></p>
<p>内部资源加载方案 大同小异,而且使用和实现缺陷非常多,实际使用价值不大.</p>
<ul>
<li><p>对于复杂的皮肤,需要太多的设置.</p>
</li>
<li><p>对于简单的皮肤(类似白天/黑夜/关灯模式),有更简单的实现方式</p>
</li>
</ul>
<p>主要来看动态加载方案</p>
<p>##resource替换<br>开源项目可参照Android-Skin-Loader</p>
<p>可以参考顶上的Blog链接</p>
<p>实现机制其实其实和遍历RootView的方案区别不大,这个是标记Skin enable后,遍历标记的view</p>
<p>遍历所有SkinItem,遍历SkinAttr,然后调用skinAtrr.apply(view)方法设置属性</p>
<p>这项目优点有2个:</p>
<ul>
<li><p>相比于遍历RootView的粗暴实现,这个实现划分层次更清晰</p>
</li>
<li><p>将资源打包成apk,然后通过AssetManager加载</p>
</li>
</ul>
<pre><code>PackageManager mPm = context.getPackageManager();
PackageInfo mInfo = mPm.getPackageArchiveInfo(skinPkgPath, PackageManager.GET_ACTIVITIES);
skinPackageName = mInfo.packageName;

AssetManager assetManager = AssetManager.class.newInstance();
Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);
addAssetPath.invoke(assetManager, skinPkgPath);

Resources superRes = context.getResources();
Resources skinResource = new Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());
</code></pre><p>实现机制ZYF写了2句,但是我感觉不是很对.</p>
<hr>
<p>自己整理一下详细实现机制如下:</p>
<p>Android-Skin-Loader并没有覆盖application的getResource方法.</p>
<ul>
<li><p>使用时必须BaseActivity </p>
</li>
<li><p>onCreate的时候调用 <code>getLayoutInflater().setFactory(mSkinInflaterFactory);</code></p>
</li>
</ul>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mSkinInflaterFactory = new SkinInflaterFactory();
    getLayoutInflater().setFactory(mSkinInflaterFactory);
}
</code></pre><ul>
<li><p>于是View被Inflater创建的时候会经过mSkinInflaterFactory的onCreateView方法</p>
</li>
<li><p>在mSkinInflaterFactory的onCreateView方法中,获取所有相关的属性,保存到SkinItem数组中</p>
</li>
<li><p>换肤的时候会调用BaseActivity的onThemeUpdate方法</p>
</li>
<li><p>onThemeUpdate方法中遍历所有SkinItem并调用apply方法修改参数</p>
</li>
</ul>
<pre><code>public void apply(View view) {        
    if(RES_TYPE_NAME_COLOR.equals(attrValueTypeName)){
        view.setBackgroundColor(SkinManager.getInstance().getColor(attrValueRefId));
    }else if(RES_TYPE_NAME_DRAWABLE.equals(attrValueTypeName)){
        Drawable bg = SkinManager.getInstance().getDrawable(attrValueRefId);
        view.setBackground(bg);
    }
}
</code></pre><ul>
<li>此时调用的getColor和getDrawable会通过AssetManager加载指定apk中的资源</li>
</ul>
<p>整个流程中没有哪里经过Application,只是通过AssetManager加载了另一个apk中的Resource.</p>
<p>比遍历RootView好一点的就是它是通过LayoutInflater的Factory去检查每个View是否需要SkinUpdate功能,然后将需要的View保存下来,ThemeUpdate的时候只刷新这些View.<br>性能上应当比遍历RootView高效一些吧.</p>
<h2 id="Hack-Resources-internally"><a href="#Hack-Resources-internally" class="headerlink" title="Hack Resources internally"></a>Hack Resources internally</h2><blockquote>
<p>引用自ZYF的Blog</p>
<p>黑科技方法，直接对Resources进行hack，Resources.java:</p>
</blockquote>
<pre><code>// Information about preloaded resources.  Note that they are not
// protected by a lock, because while preloading in zygote we are all
// single-threaded, and after that these are immutable.
private static final LongSparseArray&lt;Drawable.ConstantState&gt;[] sPreloadedDrawables;
private static final LongSparseArray&lt;Drawable.ConstantState&gt; sPreloadedColorDrawables
        = new LongSparseArray&lt;Drawable.ConstantState&gt;();
private static final LongSparseArray&lt;ColorStateList&gt; sPreloadedColorStateLists
        = new LongSparseArray&lt;ColorStateList&gt;();
</code></pre><blockquote>
<p>直接对Resources里面的这三个LongSparseArray进行替换，由于apk运行时的资源都是从这三个数组里面加载的，所以只要采用interceptor模式：<br>自己实现一个LongSparseArray，并通过反射set回去，就能实现换肤，具体getDrawable等方法里是怎么取preload数组的，可以自己看Resources的源码。<br>等等，就这么简单？，NONO，少年你太天真了，怎么去加载xml，9patch的padding怎么更新，怎么打包/加载自定义的皮肤包，drawable的状态怎么刷新，等等。这些都是你需要考虑的，在存在插件的app中，还需要考虑是否会互相覆盖resource id的问题，进而需要修改apt，把resource id按位放在2个range。<br>手Q和独立版QQ空间使用的是这种方案，效果挺好。</p>
</blockquote>
<hr>
<p>这方案也没个具体说明,就一句 <code>自己实现一个LongSparseArray</code> ,真的是蛋碎.<br>不过有个提示也是好的.</p>
<p>首先反射一下该字段看看读出来什么东西</p>
<pre><code>Resources resource = getApplicationContext().getResources();

try {
Field field =Resources.class.getDeclaredField(&quot;sPreloadedDrawables&quot;);
field.setAccessible(true);

LongSparseArray&lt;Drawable.ConstantState&gt;[]    sPreloadedDrawables = (LongSparseArray&lt;Drawable.ConstantState&gt;[] )field.get(resource);

for (LongSparseArray&lt;Drawable.ConstantState&gt; s:sPreloadedDrawables)
    for (int i = 0; i &lt; s.size(); i++) {
        System.out.println(s.valueAt(i));
    }
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (NoSuchFieldException e) {
    e.printStackTrace();
}
</code></pre><hr>
<pre><code>...
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.LayerDrawable$LayerState@8197fd4
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.LayerDrawable$LayerState@9c6357d
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.LayerDrawable$LayerState@95f0c72
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.StateListDrawable$StateListState@d78c540
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.StateListDrawable$StateListState@805ac79
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.BitmapDrawable$BitmapState@38d7dbe
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.StateListDrawable$StateListState@e829e1f
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.StateListDrawable$StateListState@4c4f56c
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.VectorDrawable$VectorDrawableState@82b9735
10-28 20:15:54.105 24502-24502/com.dk_exp.preloadhack I/System.out: android.graphics.drawable.VectorDrawable$VectorDrawableState@a9fb7ca
...
</code></pre><p>可以看到sPreloadedDrawables里持有大量的State对象,比如<code>BitmapDrawable$BitmapState</code></p>
<p>作为BitmapDrawable的内部类,还是比较简单的,贴一下完整代码</p>
<pre><code>final static class BitmapState extends ConstantState {
    final Paint mPaint;

    // Values loaded during inflation.
    int[] mThemeAttrs = null;
    Bitmap mBitmap = null;
    ColorStateList mTint = null;
    Mode mTintMode = DEFAULT_TINT_MODE;
    int mGravity = Gravity.FILL;
    float mBaseAlpha = 1.0f;
    Shader.TileMode mTileModeX = null;
    Shader.TileMode mTileModeY = null;
    int mTargetDensity = DisplayMetrics.DENSITY_DEFAULT;
    boolean mAutoMirrored = false;

    int mChangingConfigurations;
    boolean mRebuildShader;

    BitmapState(Bitmap bitmap) {
        mBitmap = bitmap;
        mPaint = new Paint(DEFAULT_PAINT_FLAGS);
    }

    BitmapState(BitmapState bitmapState) {
        mBitmap = bitmapState.mBitmap;
        mTint = bitmapState.mTint;
        mTintMode = bitmapState.mTintMode;
        mThemeAttrs = bitmapState.mThemeAttrs;
        mChangingConfigurations = bitmapState.mChangingConfigurations;
        mGravity = bitmapState.mGravity;
        mTileModeX = bitmapState.mTileModeX;
        mTileModeY = bitmapState.mTileModeY;
        mTargetDensity = bitmapState.mTargetDensity;
        mBaseAlpha = bitmapState.mBaseAlpha;
        mPaint = new Paint(bitmapState.mPaint);
        mRebuildShader = bitmapState.mRebuildShader;
        mAutoMirrored = bitmapState.mAutoMirrored;
    }

    @Override
    public boolean canApplyTheme() {
        return mThemeAttrs != null || mTint != null &amp;&amp; mTint.canApplyTheme();
    }

    @Override
    public int addAtlasableBitmaps(Collection&lt;Bitmap&gt; atlasList) {
        if (isAtlasable(mBitmap) &amp;&amp; atlasList.add(mBitmap)) {
            return mBitmap.getWidth() * mBitmap.getHeight();
        }
        return 0;
    }

    @Override
    public Drawable newDrawable() {
        return new BitmapDrawable(this, null);
    }

    @Override
    public Drawable newDrawable(Resources res) {
        return new BitmapDrawable(this, res);
    }

    @Override
    public int getChangingConfigurations() {
        return mChangingConfigurations
                | (mTint != null ? mTint.getChangingConfigurations() : 0);
    }
}
</code></pre><p>由于已经反射获得了<code>sPreloadedDrawables</code> ,那么想办法修改sPreloadedDrawables里的对象应当就可以修改 图片 资源了.</p>
<p>然而出现了多个问题</p>
<ul>
<li><p>由于<code>BitmapState</code>在类外无法访问,抽象类Drawable.ConstantState又没有提供修改的接口.</p>
</li>
<li><p>稀疏数组的key并不是ResourceId  </p>
</li>
</ul>
<pre><code>key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;
</code></pre><p>追踪一下调用栈,这个value对象来自一个native方法,暂时不方便获得assetCookie和data的计算方法</p>
<pre><code>private native final int loadResourceValue(int ident, short density, TypedValue outValue,
        boolean resolve);
</code></pre><p>不过Resource本身提供getVaklue方法来给TypeValue填充数据</p>
<pre><code>public void getValue(@AnyRes int id, TypedValue outValue, boolean resolveRefs)
</code></pre><p>那么我可以尝试直接通过TypeValue来读出preload中的数据</p>
<pre><code>TypedValue value = new TypedValue();
resource.getValue(R.drawable.charming,value,true );

long  key = -1;
if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT
        &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) {
    key = value.data;
} else {
    key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;
}
Drawable.ConstantState cs =sPreloadedDrawable.get(key);
</code></pre><p>然而这里遇到了一个问题,获取TypeValue和计算key都很正常</p>
<p>但是通过key获取ConstantState返回了null.</p>
<p>断点调试检查了LongSparseArray中的key数据,确实没有对应的值</p>
<p>调试的时候注意到这样一个问题</p>
<p>key = 8589934596</p>
<p>而LongSparseArray中的数据key为</p>
<p>4294967922<br>4294967923<br>…</p>
<p>程序员应当对这数字比较敏感</p>
<p>8589934596 = 0x200000004</p>
<p>4294967922 = 0x100000272</p>
<p>从上方key的计算逻辑中推导,可以看出是assertCookie不同</p>
<p>看起来我反射出的sPreloadedDrawables中并不一定包含我想要查找的资源</p>
<hr>
<p>翻看Resource.loadDrawable的源码,发现drawabel也可能是从mDrawableCache中获取的</p>
<p>相关代码:</p>
<pre><code>if (!mPreloading) {
    final Drawable cachedDrawable = caches.getInstance(key, theme);
    if (cachedDrawable != null) {
        return cachedDrawable;
    }
}
</code></pre><p>这个DrawableCache类本身只有包访问权限,反射代码还要写一堆,好在Debug模式下可以直接在resource里看到这个对象</p>
<p>Demo应用中drawable文件夹下只有2个资源,一张是我塞进去的测试图片,一张的ic_launch</p>
<p>检查了一下其持有的keys后,果然找到了8589934596.</p>
<p>于是下一步可以反射mDrawableCache并修改其中数据.</p>
<p>注意一个问题.这个 <code>android.content.res.DrawableCache</code> 类,只有包访问权限</p>
<p>不能使用Class.forName(“android.content.res.DrawableCache”)加载</p>
<hr>
<p>这里我犯了个错误,我调试时使用的genymotion模拟器是5.0.1的 </p>
<p>在API21版本中 drawableCache的实现是不同的</p>
<p>API21</p>
<pre><code>private final ArrayMap&lt;String, LongSparseArray&lt;WeakReference&lt;ConstantState&gt;&gt;&gt; mDrawableCache =
         new ArrayMap&lt;String, LongSparseArray&lt;WeakReference&lt;ConstantState&gt;&gt;&gt;();
</code></pre><p>API23</p>
<pre><code>private final DrawableCache mDrawableCache = new DrawableCache(this);
</code></pre><p>因为这个原因,在反射对象上浪费了一些时间,以后应当注意这个问题.<br>研究源码相关的东西时,一定要使用相同版本的设备/模拟器,不然完全是浪费时间.</p>
<hr>
<p>换成6.0设备测试了一下,成功拿到了我想要的Drawable对象</p>
<p>代码如下</p>
<pre><code>Resources resource = getApplicationContext().getResources();
 Object mdrawableCache = null;
 Field field = null;
 try {
     field = Resources.class.getDeclaredField(&quot;mDrawableCache&quot;);
 } catch (NoSuchFieldException e) {
     e.printStackTrace();
 }
 field.setAccessible(true);
 try {
     mdrawableCache = field.get(resource);
 } catch (IllegalAccessException e) {
     e.printStackTrace();
 }

 TypedValue value = new TypedValue();
 resource.getValue(R.drawable.charming,value,true );

 long  key = -1;
 if (value.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT
         &amp;&amp; value.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) {
     key = value.data;
 } else {
     key = (((long) value.assetCookie) &lt;&lt; 32) | value.data;
 }

 Method method = null;
 try {
     Class  c = mdrawableCache.getClass();
     method = c.getDeclaredMethod(&quot;getInstance&quot;,long.class,Resources.Theme.class);
 } catch (NoSuchMethodException e) {
     e.printStackTrace();
 }
 Drawable drawable = null;
 try {
     drawable = (Drawable) method.invoke(mdrawableCache, key, null);
 } catch (IllegalAccessException e) {
     e.printStackTrace();
 } catch (InvocationTargetException e) {
     e.printStackTrace();
 }
</code></pre><hr>
<p>下面考虑替换该Drawable并刷新View,参考ThemedResourceCache源码,猜测可以调用put方法把修改后的Drawable对象塞进去.</p>
<p>由于ThemeResourceCache持有的实际上还是Drawable.ConstantState对象,Drawable对象由其newDrawable()方法获取,所以应当构建BitmapState对象</p>
<p>这里依然非常蛋疼,BitmapState是BitmapDrawable的静态内部类,default,只有包访问权限.</p>
<p>无论是构造对象,调用方法,修改参数,都需要通过反射,感觉真的是非常非常麻烦.</p>
<hr>
<p>从研究过程中看,行为依赖Resource本身DrawableCache和Preload的实现,而且5.0和6.0其实现逻辑又不同.</p>
<p>通过反射hack cache来做资源替换看起来并不是一个稳妥的方案.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a><a class="article-category-link" href="/categories/android/Blog/">Blog</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Bubble-Notification-Update" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/Bubble-Notification-Update/" class="article-date">
  	<time datetime="2015-10-25T08:48:18.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/Bubble-Notification-Update/">Bubble-Notification Update</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Bubble-Notification-Update"><a href="#Bubble-Notification-Update" class="headerlink" title="Bubble-Notification Update"></a>Bubble-Notification Update</h1><p><a href="https://github.com/dkmeteor/Bubble-Notification" target="_blank" rel="external">Bubble-Notification</a></p>
<p><a href="https://github.com/dkmeteor/Bubble-Notification" target="_blank" rel="external">https://github.com/dkmeteor/Bubble-Notification</a></p>
<p><img src="/images/bubble_notification_heart.gif" alt=""></p>
<p>做了一次大更新</p>
<p>记录一下相关内容</p>
<p>#1.Bug fix</p>
<h2 id="1-1-贝塞尔曲线调整"><a href="#1-1-贝塞尔曲线调整" class="headerlink" title="1.1 贝塞尔曲线调整"></a>1.1 贝塞尔曲线调整</h2><p>看了这篇文章</p>
<p><a href="http://isux.tencent.com/qq-mobile-off-duty.html" target="_blank" rel="external">QQ手机版 5.0“一键下班”设计小结</a>以后,修改了一下贝塞尔曲线的绘制方式</p>
<p>这文章作者是个设计师,并不是程序员</p>
<p>我也没有完全按他的去画这个贝塞尔曲线,优化了一下曲线函数,主要贝塞尔曲线参考点的修改,修复几个参考点计算错误的问题</p>
<h3 id="1-2-修复由StatusBar高度导致的位置计算偏移"><a href="#1-2-修复由StatusBar高度导致的位置计算偏移" class="headerlink" title="1.2 修复由StatusBar高度导致的位置计算偏移"></a>1.2 修复由StatusBar高度导致的位置计算偏移</h3><p>检讨一下,由于这部分公式计算比较复杂,且两种绘图方式坐标不统一,代码中有大量的位置换算,导致了很多小的误差.</p>
<p>#2. 新功能</p>
<p>##2.1 添加特效</p>
<p>最近看了 <a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="external">ExplosionField</a> ,  <a href="https://github.com/ZhaoKaiQiang/Par
ticleLayout" target="_blank" rel="external">ParticleLayout</a>等项目,有了一些新的想法,打算更新一下Bubble-Notification的特效,添加几个新的.</p>
<p>由于Bubble-Notification的Explosion本身设计上是相当于一个微型粒子引擎,通过添加新粒子类型,给粒子添加更多属性和字段,可以挺方便的定制各种特效.</p>
<p>不过凑巧,那天正好戳到一个AE教程,稍微看了一下,然后我意识到, AE作为专业的特效工具,其提供的功能远远不是目前这种简陋的效果能比的.</p>
<p>结合起来也许能做一些更有趣的东西.</p>
<p>##2.2 添加GifRender</p>
<p>AE导出的效果只能是movie gif 或 序列帧,目前看来使用比较方便的只有gif和序列帧<br>先添加一个Gif支持来试试水</p>
<p>由于所有效果都直接绘制在SurfaceView上,需要自身控制,所以不方便使用第三方Gif库,好在通过android.graphics.Movie自己撸一个也很简单.</p>
<p>写了GifRender包装了一下,为了和Explosion保持一致,添加了GifUpdateThread用来刷新Gif</p>
<p>#3. 重构</p>
<p>添加GifRender过程后,由于以后可能还会添加新的特效模式,于是重构了下代码,将最后Explosion特效相关的代码从DropCover类中全部抽离,DropCover只负责贝塞尔曲线和圆形的绘制.</p>
<p>相关杂七杂八过程控制代码都丢入CoverMananger类中,这不是一个特别好的方案,不过把200行代码按OOP的方针分割成4~5个类也不是特别好的方案.暂且保持这样.如果控制过程的代码在将来会膨胀的话,到时候必须将CoverMananger中的代码拆分成各个独立的功能模块,不过目前没有必要.</p>
<hr>
<h3 id="具体算法过程描述"><a href="#具体算法过程描述" class="headerlink" title="具体算法过程描述:"></a>具体算法过程描述:</h3><p>这个一定要写一下,看半年前的代码完全看不懂了,到处都是坑,90%的问题都是 坐标点换算造成的.</p>
<pre><code>    private void drawDrop() {
    Canvas canvas = getHolder().lockCanvas();
    if (canvas != null) {
        canvas.drawColor(Color.TRANSPARENT, Mode.CLEAR);

        if (isDraw) {
            double distance = Math.sqrt(Math.pow(mBaseX - mTargetX, 2) + Math.pow(mBaseY - mTargetY, 2));
            mPaint.setColor(0xffff0000);
            mPaint.setStyle(Paint.Style.FILL);
            if (distance &lt; mMaxDistance) {
                //计算圆形半径
                mStrokeWidth = (float) ((1f - distance / mMaxDistance) * mRadius);
                //绘制 原位置的圆形,会随着拖动距离还减小,注意mBaseX,mBaseY是圆心坐标
                canvas.drawCircle(mBaseX, mBaseY, mStrokeWidth / 2, mPaint);
                drawBezier(canvas);
            }
            //绘制拖动后的图形,注意mTargetX,mTargetY是左上角坐标
            canvas.drawBitmap(mDest, mTargetX, mTargetY, mPaint);
        }
        getHolder().unlockCanvasAndPost(canvas);
    }
}
</code></pre><p>注意<code>drawCircle</code>和<code>drawBitmap</code> 使用的坐标是不一样的,一个是圆心,一个是图片左上角.<br>进行坐标计算时使用的都是 圆心坐标,可以参考下面的图片</p>
<p>注意换算,非常操蛋.</p>
<hr>
<h1 id="算法详细"><a href="#算法详细" class="headerlink" title="算法详细"></a>算法详细</h1><p>可以参考<a href="http://isux.tencent.com/qq-mobile-off-duty.html" target="_blank" rel="external">QQ手机版 5.0“一键下班”设计小结</a>,基本上是一致的,就是贝塞尔曲线的参考点不会移动</p>
<p>计算2根贝塞尔曲线的4个起点/终点</p>
<p>看代码可能不明白,还原下其实就是简单的三角函数</p>
<pre><code>/**
 * ax=by=0 x^2+y^2=s/2
 * &lt;p/&gt;
 * ==&gt;
 * &lt;p/&gt;
 * x=a^2/(a^2+b^2)*s/2
 *
 * @param start
 * @param end
 * @return
 */
private Point[] calculate(Point start, Point end) {
    float a = end.x - start.x;
    float b = end.y - start.y;

    float y1 = (float) Math.sqrt(a * a / (a * a + b * b) * (mStrokeWidth / 2f) * (mStrokeWidth / 2f));
    float x1 = -b / a * y1;

    float y2 = (float) Math.sqrt(a * a / (a * a + b * b) * (targetWidth / 2f) * (targetHeight / 2f));
    float x2 = -b / a * y2;


    Point[] result = new Point[4];

    result[0] = new Point(start.x + x1, start.y + y1);
    result[1] = new Point(end.x + x2, end.y + y2);

    result[2] = new Point(start.x - x1, start.y - y1);
    result[3] = new Point(end.x - x2, end.y - y2);

    return result;
}
</code></pre><hr>
<p>绘制贝塞尔曲线</p>
<p>贝塞尔曲线使用的参考点为 centerX,centerY,为两圆圆心连线的中点</p>
<pre><code>private void drawBezier(Canvas canvas) {

    Point[] points = calculate(new Point(mBaseX, mBaseY), new Point(mTargetX + mDest.getWidth() / 2f, mTargetY + mDest.getHeight() / 2f));

    float centerX = (points[0].x + points[1].x + points[2].x + points[3].x) / 4f;
    float centerY = (points[0].y + points[1].y + points[2].y + points[3].y) / 4f;

    Path path1 = new Path();
    path1.moveTo(points[0].x, points[0].y);
    path1.quadTo(centerX, centerY, points[1].x, points[1].y);
    path1.lineTo(points[3].x, points[3].y);

    path1.quadTo(centerX, centerY, points[2].x, points[2].y);
    path1.lineTo(points[0].x, points[0].y);
    canvas.drawPath(path1, mPaint);
}
</code></pre><p>按腾讯那文章来看,参考点随距离移动效果可能会更好,我尝试了一下,看不出明显的区别. </p>
<hr>
<p>加了个Note:</p>
<pre><code>The origin circle drawn by  canvas.drawCircle(mBaseX, mBaseY, mStrokeWidth / 2, mPaint);

so mBaseX, mBaseY are center position.

The Moved circle drawn by  canvas.drawBitmap(mDest, mTargetX, mTargetY, mPaint);

so mTargetX,mTargetY are left top corner position.
</code></pre><p>计算过程中时刻记得这2点,之前好多bug就是因为这个造成的.</p>
<hr>
<p>Explosion</p>
<p>其实这个东西非常简单.</p>
<p>一个简单的粒子生成器,实例化直接生成所有粒子</p>
<p>随机生成每个例子的颜色 x速度 y速度</p>
<p>然后由ExplosionUpdateThread刷新每个粒子的坐标并绘图</p>
<p>正常的 粒子引擎 功能要复杂的多的多, 不过上cocos2d或者别的图形/游戏引擎感觉没有必要</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-PathEffectTextView-Update" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/17/PathEffectTextView-Update/" class="article-date">
  	<time datetime="2015-10-17T06:11:43.000Z" itemprop="datePublished">2015-10-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/17/PathEffectTextView-Update/">PathEffectTextView Update</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>更新了一下<a href="https://github.com/dkmeteor/PathEffectTextView" target="_blank" rel="external">PathEffectTextView</a></p>
<ul>
<li><p>添加了字体大小 颜色 字重(bold) 阴影 等设置项.</p>
</li>
<li><p>更新了下Demo.</p>
</li>
<li><p>做了几个新的Demo Gif</p>
</li>
<li><p>发布到Jcenter</p>
</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a>TODO:</h2><ul>
<li>等有空的时候,添加各种笔刷.</li>
</ul>
<hr>
<p>#Screenshot</p>
<p>Please waiting for loading the gif…</p>
<p><img src="https://github.com/dkmeteor/PathEffectTextView/blob/master/path1.gif?raw=true" alt=""></p>
<p><img src="https://github.com/dkmeteor/PathEffectTextView/blob/master/path2.gif?raw=true" alt=""></p>
<p><img src="https://github.com/dkmeteor/PathEffectTextView/blob/master/path3.gif?raw=true" alt=""></p>
<p><img src="https://github.com/dkmeteor/PathEffectTextView/blob/master/path4.gif?raw=true" alt=""></p>
<p>#How to use</p>
<p>Step 1: add denpendence</p>
<pre><code>compile(&apos;com.dk.view.patheffect:Library:0.1.1@aar&apos;)
</code></pre><p>If you are still using <code>Eclipse</code>, you can just copy source code or jar file to you project.</p>
<p>Step 2: add view to your layout:</p>
<pre><code>&lt;com.dk.view.patheffect.PathTextView
    android:id=&quot;@+id/path&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;/&gt;
</code></pre><p>step 3: call <code>init</code> method like this:</p>
<pre><code>PathTextView mPathTextView = (PathTextView) findViewById(R.id.path);
mPathTextView.init(&quot;Hello World&quot;);
</code></pre><p>Option settings:</p>
<pre><code>mPathTextView.setPaintType(PathTextView.Type.MULTIPLY);
mPathTextView.setTextColor(color);
mPathTextView.setTextSize(size);
mPathTextView.setTextWeight(weight);
mPathTextView.setDuration(duration);
mPathTextView.setShadow(radius, dx, dy, shadowColor);
</code></pre><p>#NOTE</p>
<ul>
<li><p>Only Support capital letter, you can check this file for <a href="https://github.com/dkmeteor/PathEffectTextView/blob/master/Library/src/main/java/com/dk/view/patheffect/MatchPath.java" target="_blank" rel="external"><code>Path Data</code></a>, the data comes from <a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh/" target="_blank" rel="external">android-Ultra-Pull-To-Refresh</a></p>
</li>
<li><p>the size unit is px , 72 means 72px*72px.</p>
</li>
<li><p>the text weight unit is px.</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-SurfaceView-flashes-black-on-load" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/17/SurfaceView-flashes-black-on-load/" class="article-date">
  	<time datetime="2015-10-16T21:37:52.000Z" itemprop="datePublished">2015-10-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/17/SurfaceView-flashes-black-on-load/">SurfaceView flashes black on load</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算更新一下<a href="https://github.com/dkmeteor/Bubble-Notification" target="_blank" rel="external">Bubble-Notification</a>.</p>
<p>之前所有效果都是通过在WindowMananger上添加DropCover,然后绘制在屏幕最顶层,类似悬浮窗的处理方案,为此应用需要拥有SYSTEM_ALERT权限(这里其实我的误解,使用TYPE_APPLICATION就不需要了).</p>
<p>后来想到参考SwipeBack/ResideMenu之类类库的,可以在DecorView上操作这些东西,这样就不需要权限了.</p>
<p>修改本身蛮简单的,不过修改完后发现,在效果最开始,屏幕会闪烁一下.</p>
<p>断点调了一会,是在SurfaceView被添加进DropCover后发生的,此时SurfaceView上还未进行任何绘制.</p>
<p>奇怪的是第二次再添加SurfaceView时,又不会闪烁了,因为修改以前运行是正常的,排除了绘制的问题以后.</p>
<p>搜索了一下,发现了这个</p>
<p><a href="http://www.mzule.com/%E9%81%BF%E5%85%8D-surfaceview-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%98%BE%E7%A4%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E9%BB%91%E5%B1%8F/" target="_blank" rel="external">http://www.mzule.com/%E9%81%BF%E5%85%8D-surfaceview-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%98%BE%E7%A4%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E9%BB%91%E5%B1%8F/</a></p>
<p><a href="http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load" target="_blank" rel="external">http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load</a></p>
<p>防止链接失效摘录一下原文:</p>
<pre><code>当 SurfaceView 第一次在 Window 里面显示的时候，会触发 IWindowSession.relayout(…) 方法，该方法会 relayout 整个布局，导致屏幕黑屏一下。解决方案，就是在 Activity 加入一个默认就显示的 SurfaceView，可以通过设置它的宽度为 0，来避免用户看见它。这样在 Fragment 里面的 SurfaceView 就已经是第二个 SurfaceView 了。可以重用上一个 SurfaceView 的参数，避免的明显的屏幕黑屏。
</code></pre><p>StackOverFlow上那个答案是这样:</p>
<pre><code>I think I found the reason for the black flash. In my case I&apos;m using a SurfaceView inside a Fragment and dynamically adding this fragment to the activity after some action. The moment when I add the fragment to the activity, the screen flashes black. I checked out grepcode for the SurfaceView source and here&apos;s what I found: when the surface view appears in the window the very fist time, it requests the window&apos;s parameters changing by calling a private IWindowSession.relayout(..) method. This method &quot;gives&quot; you a new frame, window, and window surface. I think the screen blinks right at that moment.

The solution is pretty simple: if your window already has appropriate parameters it will not refresh all the window&apos;s stuff and the screen will not blink. The simplest solution is to add a 0px height plain SurfaceView to the first layout of your activity. This will recreate the window before the activity is shown on the screen, and when you set your second layout it will just continue using the window with the current parameters. I hope this helps.
</code></pre><p>在MainActivity上添加了一个0px*0px的SurfaceView以后,问题确实解决了.</p>
<hr>
<p>但是这个解决方案实在太难看了,产生问题的原因也很反常.</p>
<p>查看SurfaceView的源码,可以找到上面所说的调用位置</p>
<pre><code>protected void updateWindow(boolean force, boolean redrawNeeded){
    ...
     relayoutResult = mSession.relayout(
                        mWindow, mWindow.mSeq, mLayout, mWidth, mHeight,
                            visible ? VISIBLE : GONE,
                            WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY,
                            mWinFrame, mOverscanInsets, mContentInsets,
                            mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
    ...
} 
</code></pre><p>尝试了若干办法,绕过或者提前通过getWindow()获取Window对象设置参数都不行.</p>
<p>由于我是提供的类库,如果需要使用者自己去加个SurfaceView那也太操蛋了,这样Hack了一下</p>
<pre><code>public void init(Activity activity) {
if (mDropCover == null) {
    mDropCover = new DropCover(activity);
    mContainer = new FrameLayout(activity);

    ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
    decor.addView(mContainer);

    /**
     *
     *  WTF!
     *
     *  http://stackoverflow.com/questions/8772862/surfaceview-flashes-black-on-load
     *
     */
    SurfaceView s = new SurfaceView(activity);
    mContainer.addView(s);
    mContainer.post(new Runnable() {
        @Override
        public void run() {
            mContainer.removeAllViews();
        }
    });
}
</code></pre><p>StackOverFlow上那个提问记录还是2012年的…</p>
<hr>
<p>又仔细思索了一下,这种处理方式还是很操蛋,把这一部分重新改回了使用WindowMananger添加的方式</p>
<p>这里是我的理解有误</p>
<p>使用TYPE_APPLICATION就可以了,不需要权限.</p>
<p>之前使用的是TYPE_SYSTEM_ALERT,所以才需要权限,修改绕了一圈又回来了.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/android/">android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 DK
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/mobile.js"></script>
<script src="/js/main.js"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>